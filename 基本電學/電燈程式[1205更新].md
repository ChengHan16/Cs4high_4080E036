/*
 estar.tw iot device
 Copyright hwang 2019.02.09
 MIT license
*/
// To run, set your ESP8266 build to 160MHz, and include a SPIFFS of 256KB or greater.
// Use the "Tools->ESP8266/ESP32 Sketch Data Upload" menu to write the certs.idx to SPIFFS
// Then upload the sketch normally.  

#define DEBUG              //serial.print()
#define RELAY             //必須define板子(ESP12,WF8266,SONOFF)
//#define ONBOARDBUTTON     //只能搭配RELAY(若配合MULTIRELAY,BUTTON的數量必須與RELAY一樣)(button與relay在同一個PCB)
#define ONBOARDSWITCH     //只能搭配RELAY(若配合MULTIRELAY,SWITCH的數量必須與RELAY一樣)(sw與relay在同一個PCB)
//#define RELAYBUTTON         //必須搭配lamb帳號及define板子(遠端控制lamb遙控插座用)(不可與relay在同一個PCB)
//#define RELAYSWITCH       //必須搭配lamb帳號及define板子(遠端控制lamb遙控插座用)(不可與relay在同一個PCB)
#define ESP12               //Wemos D1沒有flash button
//#define WF8266            //NODEMCU有on board flash button 與 LED
//#define SONOFF            //必須define RELAY, ONBOARDBUTTON,不可define ONBOARDSWITCH,否則開機可能進入燒錄模式

/***********************************************************************#
//                         ┌──────┐                             #
//                         ┌─┐┌┐┌─┐                             #
//                         │  └┘└┘  │                             #
//               RST<-----1│  ││││  │16---->TX                    #
//            空  A0<-----2│  └┘└┘  │15---->RX                    #
//        繼電器  D0<-----3│   ESP12    │14---->D1  開關              #
// 馬達2 (L) din  D5<-----4│   控制版   │13---->D2  馬達1(R)          #
// 馬達1 (L)  cs  D6<-----5│   WeMos    │12---->D3  馬達1(R)          #
//           clk  D7<-----6│            │11---->D4                    #
//                D8<-----7│            │10---->G   接地(開關,繼電器) #
//               3V3<-----8│            │9----->5V  5V電源(繼電器)    #
//                         └──────┘                             #
//******************************************************************/

// must change PubSubClient.h #define MQTT_MAX_PACKET_SIZE 360  //!!! 360 > topic + payload
#include <PubSubClient.h>         //https://github.com/knolleary/pubsubclientPubSubClient.h 必須修改#define MQTT_MAX_PACKET_SIZE 300
#include <ArduinoJson.h>          //https://github.com/bblanchon/ArduinoJson
#include <ESP8266WiFi.h>          //ESP8266 2.4.2
#include <WiFiClientSecure.h>      //ESP8266 2.4.2
#include <MD5.h>                  //ESP8266 2.4.2
#include <DNSServer.h>            //ESP8266 2.4.2
#include <ESP8266WebServer.h>　  //ESP8266 2.4.2
#include <WiFiManager.h>          //https://github.com/tzapu/WiFiManager
#include <time.h>                 //提供 time() ctime() gmtime() API
#include <sys/time.h>             // struct timeval
#include <Crypto.h>             // https://github.com/intrbiz/arduino-crypto AES 128 CBC with pkcs7, RNG, SHA256 and SHA256HMAC  
#include <base64.hpp>           // Base64 encode and decode without line breaks https://github.com/Densaugeo/base64_arduino
#include <FS.h>                 //ESP8266 2.4.2
#include <CertStoreBearSSL.h>   //ESP8266 2.4.2

//此mqtt的帳號密碼public只能供實驗用,若要長期使用請向estar.tw公司花台幣2000元購買自用帳密
//每個mqtt的帳號密碼約可提供200個iot帳號使用
#define ACCOUNT_NUMBER 1  //可搭配keypad或多個SWITCH控制多個燈(帳號)
#define MULTI  1          //最多5個,只能搭配RELAY,用以設定RELAY的數量(搭配多插座multisocket帳號)
const char* COMPANY[ACCOUNT_NUMBER]= {"public"};
const char* COMPANYPASS[ACCOUNT_NUMBER]= {"public"};
/****************************/
const char* ACCOUNT[ACCOUNT_NUMBER]= {"4080E036"};
const char* PASSWORD[ACCOUNT_NUMBER]= {"R61461"};
//請填入estar.tw申請到的iot帳密與代碼
const char* SENDID[ACCOUNT_NUMBER]= {"10001229"};
const char* DEVICE[ACCOUNT_NUMBER]= {"lamb"};  //switch,rccar,sensor
/**********************************/

/************** *******************
static const uint8_t D0   = 16;
static const uint8_t D1   = 5;
static const uint8_t D2   = 4;
static const uint8_t D3   = 0;
static const uint8_t D4   = 2;
static const uint8_t D5   = 14;
static const uint8_t D6   = 12;
static const uint8_t D7   = 13;
static const uint8_t D8   = 15;
static const uint8_t D9   = 3;   // RX0 (Serial console)
static const uint8_t D10  = 1;   // TX0 (Serial console)
static const uint8_t D11  = 9;   // SD_DA2(have to rework moule)
static const uint8_t D12  = 10;  // SD_DA3(work?)
/***********************************/

#if defined(RELAY) || defined(RELAYBUTTON) || defined(MULTISWITCH) || defined(RELAYSWITCH) || defined(BUTTON) || defined(SWITCH) || defined(LEDCLOCK)
  #ifdef ESP12
  #if MULTI>=2
      const int outputpin[MULTI][ACCOUNT_NUMBER]= {{16,16,16},{16,16,16},{16,16,16}};  //d0
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{2,2,2},{2,2,2},{2,2,2}};      //d4
      const int inputpin[MULTI][ACCOUNT_NUMBER]= {{5,5,5},{4,4,4},{0,0,0}};    //d1,d2,d3
  #else
      //wemos r1,  ESP12
      const int outputpin[MULTI][ACCOUNT_NUMBER]= {{16}};  //d0-->16
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{2}};      //d4-->2
      const int inputpin[MULTI][ACCOUNT_NUMBER]= {{0}};    //d1-->5　
  #endif  //#if MULTI>=2
  #endif  //#ifdef ESP12
  #ifdef WF8266
  #if MULTI>=2
      const int outputpin[MULTI][ACCOUNT_NUMBER]= {{16},{16}};  //d0 led2
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{2},{2}};      //d4 led
      const int inputpin[MULTI][ACCOUNT_NUMBER]= {{0},{0}};    //d3  flash
  #else
      //WF8266,  ESP12-E
      const int outputpin[MULTI][ACCOUNT_NUMBER]= {{16}};  //d0-->16  led2, relay
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{2}};      //d4-->2  led
      const int inputpin[MULTI][ACCOUNT_NUMBER]= {{0}};    //d3-->0　sw2, flash button
  #endif  //#if MULTI>=2
  #endif  // if WF8266,  ESP12-E
  #ifdef SONOFF
      const int outputpin[MULTI][ACCOUNT_NUMBER]= {{12}}; //sonoff  d6  relay
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{13}};    //sonoff  d7  led
      const int inputpin[MULTI][ACCOUNT_NUMBER]= {{0}};   //sonoff  d3, flash button
  #endif
#endif  //RELAY RELAYBUTTON RELAYSWITCH BUTTON SWITCH LEDCLOCK
#if defined(RC) || defined(KEYPAD)
//      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{2}};      //d4  //use Wemos board or ESP-12 module
      const int ledpin[MULTI][ACCOUNT_NUMBER]= {{16}};      //d0  //use  NodeMCU board
#endif
#ifdef LEDCLOCK
#include <LedControl.h>
LedControl lc=LedControl(14,13,12,1); //din, clk, cs, modules D5,D7,D6建立Led物件  
#endif
WiFiClient espClient;
PubSubClient clientmqtt(espClient);
const char* mqtt_server = "mqtt.estar.tw";
char msg[50];
long mytick;

WiFiClient clienthttp;
WiFiManager wifiManager;
char charpapname[40];  //wifiManager AP name

const char* https_server = "ehome.estar.com.tw";
const int httpsPort = 443;
const int httpPort = 80;
MD5Builder md5;
unsigned long timestamp=0;
//byte prestate=0;
byte start=0;  //開機

String account;
String password;
String sid;
String rid;
String device;
String company;
char saltpassbuf[ACCOUNT_NUMBER][33];
char msgin[200];
char msgout[160];
byte mystat[MULTI][ACCOUNT_NUMBER];  //for every account
byte swstate[MULTI];  //for every key, switch or button
char tickstrbuf[11]="0000000000";
String tickstr=(char*)tickstrbuf;
unsigned long  lastMsg[MULTI];  // = 0;
unsigned long now=0;
byte flashon=0;
long value;  //on_dly or off_dly seconds
int sensortimes;

String mytopic1[ACCOUNT_NUMBER];  //for every account//acc1+
String mytopic2[ACCOUNT_NUMBER];
String mytopic3[ACCOUNT_NUMBER];  //for every account//acc2+
String mytopic4[ACCOUNT_NUMBER];
String myacc1[ACCOUNT_NUMBER];  //for every account
String myacc2[ACCOUNT_NUMBER];

#if defined(RC) || defined(KEYPAD)
#include <Keypad.h>
const int D1pin= 5;
const int D2pin= 4;
const int D3pin= 0;
//const int D0pin= 16;  //16 is D0 , D4 is 2
const int D4pin= 2;  //16 is D0,is nodeMCU' on board LED.  D4 is 2, is on ESP12 module LED
const int D5pin= 14;
const int D6pin= 12;
const int D7pin= 13;
const int D8pin= 15;

const byte ROWS = 4; //four rows
const byte COLS = 4; //four columns
//define the cymbols on the buttons of the keypads
char hexaKeys[ROWS][COLS] = {
/********key map 0123/4567/89AB/CDEF******
  {'0','1','2','3'},
  {'4','5','6','7'},
  {'8','9','A','B'},
  {'C','D','E','F'}
/********key map FEDC/B369/A258/0147*******/
  {'0','6','2','3'},
  {'9','5','1','7'},
  {'8','4','A','B'},
  {'C','D','E','F'}
/***************/
};
byte rowPins[ROWS] = {D4pin, D3pin, D2pin, D1pin}; //connect to the row pinouts of the keypad
byte colPins[COLS] = {D8pin, D7pin, D6pin ,D5pin}; //connect to the column pinouts of the keypad

//initialize an instance of class NewKeypad
Keypad customKeypad = Keypad( makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS); 
#endif
#ifdef RCCAR
    //L9110
    int carspeed;
    #ifdef L9110
    const int pinleft1=14;  //D5
    const int pinleft2=12;  //D6
    const int ledleft=13;   //D7
    const int pinright1=4;  //D2
    const int pinright2=0;  //D3
    const int ledright=15;  //D8
    void initcar(){
        pinMode(pinleft1, OUTPUT);     // Initialize the motor pin as an output
        pinMode(pinleft2, OUTPUT);     // Initialize the motor pin as an output
        pinMode(ledleft, OUTPUT);     // Initialize the LED pin as an output
        pinMode(pinright1, OUTPUT);     // Initialize the motor pin as an output
        pinMode(pinright2, OUTPUT);     // Initialize the motor pin as an output
        pinMode(ledright, OUTPUT);     // Initialize the LED pin as an output
        mystat=0;
    }
    void turn_r (){
      digitalWrite(pinleft1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinleft2, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledleft, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledright, LOW);  // Turn the LED on by making the voltage LOW
    }
    void turn_l(){
      digitalWrite(pinleft1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinleft2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledleft, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright2, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledright, HIGH);  // Turn the LED on by making the voltage LOW
    }
    void turn_b(){
      digitalWrite(pinleft1, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinleft2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledleft, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright1, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledright, HIGH);  // Turn the LED on by making the voltage LOW
    }
    void turn_f(){
      digitalWrite(pinleft1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinleft2, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledleft, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright2, HIGH);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledright, HIGH);  // Turn the LED on by making the voltage LOW
    }
    void carstop(){
      digitalWrite(pinleft1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinleft2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledleft, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright1, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(pinright2, LOW);  // Turn the LED on by making the voltage LOW
      digitalWrite(ledright, LOW);  // Turn the LED on by making the voltage LOW
    }
#endif  //L9110
//L293D    
#ifdef L293D
    //Initialize Digital Pins
    const int leftForward = 5;  //A D1=5 high en，D3=0
    const int leftBackward = 0;
    const int rightForward = 4;  //B D2=4 high en，D4=2
    const int rightBackward = 2;
    void initcar(){
      pinMode(leftForward,OUTPUT);   //speed
      pinMode(leftBackward,OUTPUT);  //dir HIGH=for  LOW=back
      pinMode(rightForward,OUTPUT);  //speed
      pinMode(rightBackward,OUTPUT); //dir HIGH=for  LOW=back
      mystat[0][0]=0;
      carspeed=0;
    }
    void turn_r (){
      analogWrite(leftForward,850+carspeed*20);   //speed
      digitalWrite(leftBackward,HIGH);            //dir HIGH=for  LOW=back
      analogWrite(rightForward,600);  //speed
      digitalWrite(rightBackward,HIGH);           //dir HIGH=for  LOW=back
    }
    void turn_br (){
      analogWrite(leftForward,600);   //speed
      digitalWrite(leftBackward,LOW);             //dir HIGH=for  LOW=back
      analogWrite(rightForward,850+carspeed*20);  //speed
      digitalWrite(rightBackward,LOW);            //dir HIGH=for  LOW=back
    }
    void turn_rd (){
      digitalWrite(leftForward,HIGH);
      digitalWrite(leftBackward,HIGH);
      digitalWrite(rightForward,LOW);
      digitalWrite(rightBackward,LOW);
    }
    void turn_l (){
      analogWrite(leftForward,600);  //speed
      digitalWrite(leftBackward,HIGH);     //dir HIGH=for  LOW=back
      analogWrite(rightForward,850+carspeed*20); //speed
      digitalWrite(rightBackward,HIGH);     //dir HIGH=for  LOW=back
    }
    void turn_bl (){
      analogWrite(leftForward,850+carspeed*20);  //speed
      digitalWrite(leftBackward,LOW);     //dir HIGH=for  LOW=back
      analogWrite(rightForward,600); //speed
      digitalWrite(rightBackward,LOW);     //dir HIGH=for  LOW=back
    }
    void turn_ld (){
      digitalWrite(leftForward,LOW);
      digitalWrite(leftBackward,LOW);
      digitalWrite(rightForward,HIGH);
      digitalWrite(rightBackward,HIGH);
    }
    void turn_f (){
      analogWrite(leftForward,850+carspeed*20); //speed
      digitalWrite(leftBackward,HIGH);      //dir HIGH=for  LOW=back
      analogWrite(rightForward,850+carspeed*20);  //speed
      digitalWrite(rightBackward,HIGH);      //dir HIGH=for  LOW=back
    }
    void turn_fd (){
      digitalWrite(leftForward,HIGH);
      digitalWrite(leftBackward,HIGH);
      digitalWrite(rightForward,HIGH);
      digitalWrite(rightBackward,HIGH);
    }
    void turn_b (){
      analogWrite(leftForward,850+carspeed*20);  //speed
      digitalWrite(leftBackward,LOW);       //dir HIGH=for  LOW=back
      analogWrite(rightForward,850+carspeed*20); //speed
      digitalWrite(rightBackward,LOW);      //dir HIGH=for  LOW=back
     }
    void turn_bd (){
      digitalWrite(leftForward,HIGH);
      digitalWrite(leftBackward,LOW);
      digitalWrite(rightForward,HIGH);
      digitalWrite(rightBackward,LOW);
    }
    void carstop(){
      digitalWrite(leftForward,LOW);
      digitalWrite(leftBackward,LOW);
      digitalWrite(rightForward,LOW);
      digitalWrite(rightBackward,LOW);
    }
#endif  //L293D
#endif　// RCCAR

class SPIFFSCertStoreFile : public BearSSL::CertStoreFile {
  public:
    SPIFFSCertStoreFile(const char *name) {
      _name = name;
    };
    virtual ~SPIFFSCertStoreFile() override {};

    virtual bool open(bool write = false) override {
      _file = SPIFFS.open(_name, write ? "w" : "r");
      return _file;
    }
    virtual bool seek(size_t absolute_pos) override {
      return _file.seek(absolute_pos, SeekSet);
    }
    virtual ssize_t read(void *dest, size_t bytes) override {
      return _file.readBytes((char*)dest, bytes);
    }
    virtual ssize_t write(void *dest, size_t bytes) override {
      return _file.write((uint8_t*)dest, bytes);
    }
    virtual void close() override {
      _file.close();
    }

  private:
    File _file;
    const char *_name;
};
  BearSSL::CertStore certs;
  SPIFFSCertStoreFile certs_idx("/certs.idx"); // declare certs_idx Generated by the ESP8266
  SPIFFSCertStoreFile certs_ar("/certs.ar");   // declare certs_ar Uploaded by the user
  BearSSL::WiFiClientSecure clientsecu;

#define BLOCK_SIZE 16
uint8_t key[BLOCK_SIZE] = { 0x1C,0x3E,0x4B,0xAF,0x13,0x4A,0x89,0xC3,0xF3,0x87,0x4F,0xBC,0xD7,0xF3, 0x31, 0x31 };
uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

//prepare key and iv, set key=saltpassbuf iv=mqtt_encr
void setkeyiv(int arrayid, String mqtt_encr){
  int i,j;
//prepare key
#if defined(DEBUG1) 
   Serial.print("key: 0x");
#endif
   for(i=0; i<32; i=i+2 ){
    if(saltpassbuf[arrayid][i]<=0x39 && saltpassbuf[arrayid][i]>=0x30){
        j=(saltpassbuf[arrayid][i] & 0x0f)<<4;
    }else{
        j=((saltpassbuf[arrayid][i] & 0x0f )+ 0x09)<<4; //a-->0x0a
    }
    if(saltpassbuf[arrayid][i+1]<=0x39 && saltpassbuf[arrayid][i+1]>=0x30){
        key[i/2]=j | (saltpassbuf[arrayid][i+1] & 0x0f);
    }else{
        key[i/2]=j | ((saltpassbuf[arrayid][i+1] & 0x0f) + 0x09); //a-->0x0a
    }
#if defined(DEBUG1) 
    Serial.print(key[i/2],HEX);
    Serial.print(", 0x");
   }
   Serial.println("}");
//prepare iv
   Serial.print("iv: { 0x");
#else
  }
#endif
   for(i=0; i<32; i=i+2 ){
    if(mqtt_encr[i]<=0x39 && mqtt_encr[i]>=0x30){
        j=(mqtt_encr[i] & 0x0f)<<4;
    }else{
        j=((mqtt_encr[i] & 0x0f) + 0x09)<<4; //a-->0x0a
    }
    if(mqtt_encr[i+1]<=0x39 && mqtt_encr[i+1]>=0x30){
        iv[i/2]= j | (mqtt_encr[i+1] & 0x0f);
    }else{
        iv[i/2]= j | ((mqtt_encr[i+1] & 0x0f) + 0x09); //a-->0x0a
    }
#if defined(DEBUG1) 
    Serial.print(iv[i/2],HEX);
    Serial.print(", 0x");
   }
   Serial.println("}");
#else
  }
#endif
}

void bufferSize(char* text, int &length){
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
}
    
void encrypt(char* plain_text, char* output, int &length){
  byte enciphered[length];
  AES aesEncryptor(key, iv, AES::AES_MODE_128, AES::CIPHER_ENCRYPT);
  aesEncryptor.process((uint8_t*)plain_text, enciphered, length);
  int encrypted_size = sizeof(enciphered);
  char encoded[encrypted_size];
  encode_base64(enciphered, encrypted_size, (unsigned char*)encoded);
  strcpy(output, encoded);
}

void decrypt(char* enciphered, char* output, int length){
  length = length + 1; //re-adjust
  char decoded[length];
  decode_base64((unsigned char*)enciphered, (unsigned char*)decoded);
  bufferSize(enciphered, length);
  byte deciphered[length];
  AES aesDecryptor(key, iv, AES::AES_MODE_128, AES::CIPHER_DECRYPT);
  aesDecryptor.process((uint8_t*)decoded, deciphered, length);
  strcpy(output, (char*)deciphered);
}

#if defined(DEBUG3) 
#define PTM(w) \
  Serial.print(":" #w "="); \
  Serial.print(tm->tm_##w);
void printTm(const char* what, const tm* tm) {
  Serial.print(what);
  PTM(isdst); PTM(yday); PTM(wday);
  PTM(year);  PTM(mon);  PTM(mday);
  PTM(hour);  PTM(min);  PTM(sec);
}
#endif
//#if !(defined(RC) && defined(KEYPAD))    //KEYPAD無是假
#if !(defined(RC) || defined(KEYPAD))    //KEYPAD有是真
//#if !(defined(RC)) // || defined(KEYPAD))  //KEYPAD有是真
void callback(char* topic, byte* payload, unsigned int length) {
int i,j;
int arrayid;

#if defined(DEBUG1) 
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.println("] ");
#endif
  String topicinstr=topic;
  char tempaccbuf[33];
  String tempacc;
  char temptimestampbuf[12];
  String temptimestamp;
  String temptopic;
#if ACCOUNT_NUMBER >= 2   //到 line 739
//取出topic 中的acc
  for(arrayid=0; arrayid<ACCOUNT_NUMBER; arrayid++){
    company=(String)COMPANY[arrayid];
    j=company.length()+1;
    for(i=0; i<32; i++){
#if defined(DEBUG1) 
    Serial.print((char)topic[j+i]);
#endif
      tempaccbuf[i]=topic[j+i];
    }
      tempaccbuf[i]=0;
    tempacc=(String)tempaccbuf;
    temptopic=(String)mytopic1[arrayid];
    j=temptopic.length()+1;
    for(i=0; i<11; i++){
#if defined(DEBUG1) 
    Serial.print((char)topic[j+i]);
#endif
      temptimestampbuf[i]=topic[j+i];
    }
      temptimestampbuf[i]=0;
    temptimestamp=(String)temptimestampbuf;
#if defined(DEBUG) 
    Serial.println();
    Serial.print(temptimestamp.toInt());
#endif
    if(long(timestamp-temptimestamp.toInt())>3 && long(timestamp-temptimestamp.toInt())<-3){
        return;
    }
#if defined(DEBUG1) 
    Serial.println();
    Serial.print(tempacc);
    Serial.print(myacc1[arrayid]);
    Serial.print(myacc2[arrayid]);
    Serial.println();
    Serial.println(mytopic1[arrayid]);
    Serial.println(mytopic2[arrayid]);
    Serial.println(mytopic3[arrayid]);
    Serial.println(mytopic4[arrayid]);
#endif
    if(myacc1[arrayid].startsWith(tempacc) || myacc2[arrayid].startsWith(tempacc)){
//    if(myacc1[arrayid].indexOf(tempacc) || myacc2[arrayid].indexOf(tempacc)){
        break;
    }
  }
  if(arrayid==4)
      return;
#else //#if ACCOUNT_NUMBER >= 2
  arrayid=0;
    temptopic=(String)mytopic1[arrayid];
    j=temptopic.length()+1;
    for(i=0; i<11; i++){
#if defined(DEBUG1) 
      Serial.print((char)topic[j+i]);
#endif
      temptimestampbuf[i]=topic[j+i];
    }
      temptimestampbuf[i]=0;
    temptimestamp=(String)temptimestampbuf;
#if defined(DEBUG) 
    Serial.println();
    Serial.print(temptimestamp.toInt());
#endif
#endif  //#if ACCOUNT_NUMBER >= 2
#if defined(DEBUG1) 
    Serial.println(arrayid);
#endif
  for ( i = 0; i < 200; i++) {
      msgin[i]=0;
  }
  for ( i = 0; i < 160; i++) {
    msgout[i]=0;
  }
//取得topic, mqttmessage
  for ( i = 0; i < length; i++) {
#if defined(DEBUG1) 
    Serial.print((char)payload[i]);
#endif
    msgin[i]=payload[i];
  }
  msgin[i]=0;
#if defined(DEBUG) 
  Serial.println();
#endif
String mqttin=(String)msgin;
String topicin="";
char char1;
#if defined(DEBUG) 
    Serial.println(topicinstr);
#endif
  if(topicinstr.startsWith(mytopic1[arrayid]) || topicinstr.startsWith(mytopic2[arrayid]) || topicinstr.startsWith(mytopic3[arrayid]) || topicinstr.startsWith(mytopic4[arrayid])){ //是否我所監聽的rule topic
//  if(topicinstr.indexOf(mytopic1[arrayid]) || topicinstr.indexOf(mytopic2[arrayid]) || topicinstr.indexOf(mytopic3[arrayid]) || topicinstr.indexOf(mytopic4[arrayid])){ //是否我所監聽的rule topic
//是自己要監聽的topic
// my topic
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino mqttin get mytopic!");
#endif // DEBUG
      if (mqttin.startsWith("{\"state\":\"aes\"")) {  //正確的格式
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino mqttin state get aes!");
#endif // DEBUG
        // Allocate the JSON document
        // Use arduinojson.org/assistant to compute the capacity.
         StaticJsonBuffer<300> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(mqttin);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("mqtt message parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* mqtt_aes = root["aes"]; // "1542554926"
//        String mqtt_aes = root["aes"]; // "1542554926"
        const char* mqtt_encr = root["encr"]; // "6bbb545f010c1d16060957602a870712" 
#if defined(DEBUG1) 
        Serial.print(F("mqtt aes ok, mqtt_aes:"));
        Serial.println(mqtt_aes);
        Serial.println(mqtt_encr);
#endif  // DEBUG
//prepare key and iv, set key=saltpassbuf iv=mqtt_encr
    setkeyiv(arrayid, mqtt_encr); //解密之前要先取得id
  // decrypt
  int length =strlen( mqtt_aes);
//  int length =mqtt_aes.length();
  char decrypted[length];
//  decrypt((char)mqtt_aes, decrypted, length);
  decrypt((char*)mqtt_aes, decrypted, length);
//  decrypted[length]=0;
#if defined(DEBUG) 
  Serial.print("Decrypted lengthdec: ");
  Serial.println(length);
  Serial.print("Decrypted: ");
  Serial.println(decrypted);
#endif
String decryptedstr=(String)decrypted;
 if (decryptedstr.startsWith("{\"state\":\"ok\"")) {  //正確的格式
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino mqttin state get aes ok state!");
#endif // DEBUG
         StaticJsonBuffer<300> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(decrypted);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("parseObject() failed");
#endif
            return;
          }
        String mqtt_ts = root["ts"]; // "1542554926"
        String mqtt_rid = root["rid"]; // "2186"
        String mqtt_sid = root["sid"]; // "2186"
        String mqtt_message = root["msg"]; // "on"
#if defined(DEBUG) 
        Serial.print(F("mqtt ok, timestamp:"));
        Serial.println(mqtt_ts);
#endif  // DEBUG
if(!temptimestamp.startsWith(mqtt_ts)){
#if defined(DEBUG) 
        Serial.print(F("mqtt ok, timestamp error!"));
#endif  // DEBUG
  return;
}
#if defined(DEBUG1) 
        Serial.println(F("mqtt ok, rid, sid, message, ts:"));
        Serial.println(mqtt_rid);
        Serial.println(mqtt_sid);
        Serial.println(mqtt_message);
        Serial.println(mqtt_ts);
#endif  // DEBUG
//準備計算payload的核對碼
  for ( i = 0; i < mqtt_rid.length(); i++) {
#if defined(DEBUG1) 
    Serial.print((char)mqtt_rid[i]);
#endif
    msgout[i]=mqtt_rid[i];
  }
  for ( j = i; j < mqtt_message.length()+i; j++) {
#if defined(DEBUG1) 
    Serial.print((char)mqtt_message[j-i]);
#endif
    msgout[j]=mqtt_message[j-i];
  }
  for ( i = j; i < mqtt_sid.length()+j; i++) {
#if defined(DEBUG1) 
    Serial.print((char)mqtt_sid[i-j]);
#endif
    msgout[i]=mqtt_sid[i-j];
  }
  for ( j = i; j < mqtt_ts.length()+i; j++) {
#if defined(DEBUG1) 
    Serial.print((char)mqtt_ts[j-i]);
#endif
    msgout[j]=mqtt_ts[j-i];
  }
  int k;
#if ACCOUNT_NUMBER >=2
  for(k=0; k<ACCOUNT_NUMBER; k++){
    String tempid=(String)SENDID[k];
    if(mqtt_rid.toInt()==tempid.toInt()){
      break;
    }
  }
#else
  k=0;
#endif
#if defined(DEBUG1) 
    Serial.println(k);
#endif
  for ( i = j; i < 32+j; i++) {
#if defined(DEBUG1) 
    Serial.print(saltpassbuf[k][i-j]);
#endif
    msgout[i]=saltpassbuf[k][i-j];
  }
  msgout[i]=0;
#if defined(DEBUG1) 
       Serial.println();
#endif
 String encrStrout=(String)msgout;
#if defined(DEBUG1) 
  Serial.print("encrStr:");
        Serial.println(encrStrout);
#endif
        md5.begin();
        md5.add(encrStrout);
        md5.calculate();
#if defined(DEBUG) 
       Serial.print("md5.toString(encrStrout):");
        Serial.println(md5.toString());
#endif
 //check mqtt payload
       if(md5.toString().indexOf(mqtt_encr)==0){ //正確的編碼
#if defined(DEBUG) 
       Serial.println("mqtt receive ok and encr ok");
#endif  // DEBUG
           timestamp=mqtt_ts.toInt(); //對時
           now=millis();
           
#ifdef RCCAR
           if( mqtt_message.indexOf("on_left")==0){
             if(carspeed<10)
                carspeed++;
              if(mystat[0][0]==2 || mystat[0][0]==23){  //back
                turn_bl();
                mystat[0][0]=23;
              }else {  //for, left,right
                turn_l();
                mystat[0][0]=3;
              }
#if defined(DEBUG1) 
       Serial.println("rc car left:");
#endif
           } else  if( mqtt_message.indexOf("on_right")==0){
             if(carspeed<10)
                carspeed++;
              if(mystat[0][0]==2 || mystat[0][0]==24){  //back
                turn_br();
                mystat[0][0]=24;
              }else {  //for, left,right
                turn_r();
                mystat[0][0]=4;
              }
#if defined(DEBUG1) 
       Serial.println("rc car right:");
#endif
          } else  if( mqtt_message.indexOf("on_for")==0){
             if(carspeed<10)
                carspeed++;
             turn_f();
             mystat[0][0]=1;
#if defined(DEBUG1) 
       Serial.println("rc car forward:");
#endif
          } else  if( mqtt_message.indexOf("on_back")==0){
             if(carspeed<10)
                carspeed++;
             turn_b();
             mystat[0][0]=2;
#if defined(DEBUG1) 
              Serial.println("rc car back:");
#endif
          } else  if( mqtt_message.indexOf("off")==0){
              carspeed=0;
              carstop();
              mystat[0][0]=0;
#if defined(DEBUG1) 
              Serial.println("rc car stop:");
#endif
           }
#endif  // RCCAR

#if defined(RELAY) || defined(RELAYBUTTON) || defined(RELAYSWITCH) || defined(LEDCLOCK) || defined(BUTTON) || defined(SWITCH)
//RELAY就代表ONBOARDBUTTON與ONBOARDSWITCH,除了RC與RCCAR都會處理dly訊息
#if  MULTI>=2
//#if defined(RELAY) || defined(SWITCH) || defined(BUTTON)
           if( mqtt_message.indexOf("on_dly_")==0){  //on_dly_1_  on_dly_5_
               char1=mqtt_message.charAt(7); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
//               lastMsg=4000000000;
#if defined(DEBUG1) 
              Serial.print("esp8266 mqtt get on_dly_x timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[0]);
#endif
               mystat[i][0]=2;
//               tickstr[i]="";
               tickstr="";
               for (int j=9; j<mqtt_message.length(); j++){
                    char1=mqtt_message.charAt(j);
//                    tickstr[i]=tickstr[i]+char1;  //如何取出秒數
                    tickstr=tickstr+char1;  //如何取出秒數
                }
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
               digitalWrite(outputpin[i][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
               digitalWrite(ledpin[i][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
//               mytick=tickstr[i].toInt();   //mytick只是作為一個訊標用於是否決定設定lastMsg
               mytick=tickstr.toInt();   //mytick只是作為一個訊標用於是否決定設定lastMsg
#if defined(DEBUG) 
              Serial.print("tickstr:");
//              Serial.println(tickstr[i]);
              Serial.println(tickstr);
#endif
           } else  if( mqtt_message.indexOf("off_dly_")==0){  //off_dly_1_
               char1=mqtt_message.charAt(8); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
//               lastMsg=4000000000;
#if defined(DEBUG1) 
              Serial.print("esp8266 mqtt get off_dly_x timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[0]);
#endif
               mystat[i][0]=3;
//               tickstr[i]="";
               tickstr="";
               for (int j=10; j<mqtt_message.length(); j++){
                  char1=mqtt_message.charAt(j);
//                  tickstr[i]=tickstr[i]+char1;  //如何取出秒數
                  tickstr=tickstr+char1;  //如何取出秒數
              }
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
             digitalWrite(outputpin[i][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[i][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
//             mytick=tickstr[i].toInt();  //mytick只是作為一個訊標用於是否決定設定lastMsg
             mytick=tickstr.toInt();  //mytick只是作為一個訊標用於是否決定設定lastMsg
#if defined(DEBUG) 
             Serial.print("tickstr:");
//             Serial.println(tickstr[i]);
             Serial.println(tickstr);
#endif
          } else
//#endif  // RELAY SWITCH BUTTON
          if( mqtt_message.indexOf("on_")==0){  //on_1
#if defined(DEBUG) 
              Serial.println("esp8266 mqtt get on_x");
#endif
               char1=mqtt_message.charAt(3); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
             mystat[i][0]=1;
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
            digitalWrite(outputpin[i][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[i][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
          } else  if( mqtt_message.indexOf("off_")==0){  //off_1
#if defined(DEBUG) 
              Serial.println("esp8266 off_x");
#endif
               char1=mqtt_message.charAt(4); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
             mystat[i][0]=0;
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
            digitalWrite(outputpin[i][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[i][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
          }
#else  //MULTI>=2  // RELAY || BUTTON || SWITCH ||LEDCLOCK
//RELAYBUTTON   RELAYSWITCH 不用接收on_dly與off_dly
//#if defined(RELAY) || defined(SWITCH) || defined(BUTTON)
           if( mqtt_message.indexOf("on_dly")==0){
             mystat[0][0]=2;
#if defined(DEBUG) 
              Serial.print("esp8266 mqtt get on_dly timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[0]);
#endif
               tickstr="";
             for (int j=6; j<mqtt_message.length(); j++){
                  char1=mqtt_message.charAt(j);
                  tickstr=tickstr+char1;  //如何取出秒數
              }
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
             digitalWrite(outputpin[0][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
             mytick=tickstr.toInt(); //mytick只是作為一個訊標用於是否決定設定lastMsg
#if defined(DEBUG) 
              Serial.print("tickstr:");
              Serial.println(tickstr);
#endif
           } else  if( mqtt_message.indexOf("off_dly")==0){
               mystat[0][0]=3;
#if defined(DEBUG) 
              Serial.print("esp8266 mqtt get off_dly timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[0]);
#endif
               tickstr="";
               for (int j=7; j<mqtt_message.length(); j++){
                  char1=mqtt_message.charAt(j);
                  tickstr=tickstr+char1;  //如何取出秒數
              }
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
             digitalWrite(outputpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
             mytick=tickstr.toInt();  //mytick只是作為一個訊標用於是否決定設定 lastMsg
#if defined(DEBUG) 
             Serial.print("tickstr:");
             Serial.println(tickstr);
#endif
          } else 
#endif  //MULTI //RELAY BUTTON SWITCH
//on, off 是所有lamb 帳號都需要的
          if( mqtt_message.indexOf("on")==0){
             mystat[0][0]=1;
#if defined(DEBUG) 
              Serial.println("esp8266 mqtt get on");
#endif
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
            digitalWrite(outputpin[0][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
          } else  if( mqtt_message.indexOf("off")==0){
             mystat[0][0]=0;
#if defined(DEBUG) 
              Serial.println("esp8266 mqtt get off");
#endif
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
            digitalWrite(outputpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][0], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
          }
#endif  // RELAY || BUTTON || SWITCH ||LEDCLOCK

#ifdef MULTISWITCH
           if( mqtt_message.indexOf("on_dly")==0){
             mystat[0][arrayid]=2;
#if defined(DEBUG) 
              Serial.print("esp8266 mqtt get on_dly timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[0]);
#endif
               tickstr="";
             for (int j=6; j<mqtt_message.length(); j++){
                  char1=mqtt_message.charAt(j);
                  tickstr=tickstr+char1;  //如何取出秒數
              }
#if defined(ESP12) || defined(WF8266) 
             digitalWrite(outputpin[0][arrayid], HIGH);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][arrayid], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
             mytick=tickstr.toInt(); //mytick只是作為一個訊標用於是否決定設定lastMsg
#if defined(DEBUG) 
              Serial.print("tickstr:");
              Serial.println(tickstr);
#endif
           } else  if( mqtt_message.indexOf("off_dly")==0){
               mystat[0][arrayid]=3;
#if defined(DEBUG) 
              Serial.print("esp8266 mqtt get off_dly timestamp lastMsg[0]:");
              Serial.print(timestamp);
              Serial.print(", ");
              Serial.println(lastMsg[arrayid]);
#endif
               tickstr="";
               for (int j=7; j<mqtt_message.length(); j++){
                  char1=mqtt_message.charAt(j);
                  tickstr=tickstr+char1;  //如何取出秒數
              }
#if defined(ESP12) || defined(WF8266) 
             digitalWrite(outputpin[0][arrayid], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][arrayid], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
             mytick=tickstr.toInt();  //mytick只是作為一個訊標用於是否決定設定 lastMsg
#if defined(DEBUG) 
             Serial.print("tickstr:");
             Serial.println(tickstr);
#endif
          } else 
//on, off 是所有lamb 帳號都需要的
          if( mqtt_message.indexOf("on")==0){
             mystat[0][arrayid]=1;
#if defined(DEBUG) 
              Serial.println("esp8266 mqtt get on");
#endif
#if defined(ESP12) || defined(WF8266) 
            digitalWrite(outputpin[0][arrayid], HIGH);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][arrayid], LOW);   // Turn the LED on (Note that LOW is the voltage level
#endif
          } else  if( mqtt_message.indexOf("off")==0){
             mystat[0][arrayid]=0;
#if defined(DEBUG) 
              Serial.println("esp8266 mqtt get off");
#endif
#if defined(ESP12) || defined(WF8266)
            digitalWrite(outputpin[0][arrayid], LOW);   // Turn the LED on (Note that LOW is the voltage level
             digitalWrite(ledpin[0][arrayid], HIGH);   // Turn the LED on (Note that LOW is the voltage level
#endif
          }
#endif  // MULTSWITCH

       } //if mqtt_encr
      } //if decryptedstr  state:ok
    }else{   //if state:aes
#if defined(DEBUG1) 
         Serial.println("esp8266/Arduino mqtt in no aes.");
#endif
    }       //if state:aes
  }  //  if(topicinstr.startsWith(mytopic1[arrayid]) || topicinstr.startsWith(mytopic2[arrayid]) || topicinstr.startsWith(mytopic3[arrayid]) || topicinstr.startsWith(mytopic4[arrayid])){ //是否我所監聽的rule topic
#if defined(DEBUG1) 
         Serial.println("esp8266/Arduino mqtt in not my.");
#endif
}  //mqttcallback
#endif  //#ifndef RC

void reconnectmqtt(int arrayid) {
account=(String)ACCOUNT[arrayid];
sid=(String)SENDID[arrayid];
company=(String)COMPANY[arrayid];
String saltpass=(char*)saltpassbuf[arrayid];
char subscribechar[88];  //轉換string成char用的buffer
String mqttclientid=sid+account+random(1000000,9999999);
int i;
  for ( i = 0; i < mqttclientid.length(); i++) {
#if defined(DEBUG1) 
    Serial.print((char)mqttclientid[i]);
#endif
    subscribechar[i]=(char)mqttclientid[i];
  }
  subscribechar[i]=0;
#if defined(DEBUG1) 
   Serial.println();
#endif
  // Loop until we're reconnected
  while (!clientmqtt.connected()) {
#if defined(DEBUG1) 
    Serial.print("Attempting MQTT connection...");
#endif
    // Attempt to connect
    if (clientmqtt.connect(subscribechar,COMPANY[arrayid],COMPANYPASS[arrayid])) {  //mqttclientid
#if defined(DEBUG) 
        Serial.println("mqtt connected");
#endif
       // ...  resubscribe
String subscribestr;

      subscribestr=company+"/#";
      for ( i = 0; i < subscribestr.length(); i++) {
#if defined(DEBUG) 
        Serial.print((char)subscribestr[i]);
#endif
        subscribechar[i]=(char)subscribestr[i];
      }
      subscribechar[i]=0;
#if defined(DEBUG) 
      Serial.println();
#endif
      clientmqtt.subscribe(subscribechar);
    } else {
#if defined(DEBUG) 
      Serial.print("failed, mqtt rc=");
      Serial.print(clientmqtt.state());
      Serial.println(" try again in 3 seconds");
#endif
      // Wait 3 seconds before retrying
      delay(3000);
    }
  }
}

void httpconnect(){
#if defined(DEBUG1) 
  Serial.print("http connecting to ");
  Serial.println(https_server);
#endif
    if (!clienthttp.connect(https_server, httpPort)) {  //雖與後面重複,但這個不可刪除
#if defined(DEBUG) 
        Serial.println("connection failed");
#endif
    }
    while (!clienthttp.connected()) {
      if (!clienthttp.connect(https_server, httpPort)) {
#if defined(DEBUG) 
        Serial.println("connection failed");
#endif
      }
    }
}  //httpconnect()

void httpsconnect(){
  SPIFFS.begin();
  time_t httpnow=timestamp;

  clientsecu.setX509Time(httpnow);
  clientsecu.setCertStore(&certs);
#if defined(DEBUG1) 
  Serial.print("https connecting to ");
  Serial.println(https_server);
#endif
    if (!clientsecu.connect(https_server, httpsPort)) {  //雖與後面重複,但這個不可刪除
#if defined(DEBUG) 
        Serial.println("connection failed");
#endif
    }
    while (!clientsecu.connected()) {
      if (!clientsecu.connect(https_server, httpsPort)) {
#if defined(DEBUG) 
        Serial.println("connection failed");
#endif
      }
    }
  SPIFFS.end();
}  //httpsconnect()

void httppoststamp(){
int i;

httpconnect();
String url = "/hwang/esp8266/arduino/esp8266stamp.php";
  String postData = "st=hello";
#if defined(DEBUG1) 
  Serial.print("httppoststr requesting URL: ");
  Serial.println(url);
  Serial.print("?");
  Serial.println(postData);
#endif

clienthttp.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + https_server+ ":"+ httpsPort + "\r\n" +
               "User-Agent: BuildFailureDetectorESP8266\r\n" +
               "Accept: */*\r\n" +
              "Content-Type: application/x-www-form-urlencoded\r\n" +
               "Content-Length: " + postData.length() + "\r\n" +
               "Connection: close\r\n\r\n");
 clienthttp.print(postData);

#if defined(DEBUG1) 
  Serial.println("poststr request sent");
#endif
  while (clienthttp.connected()) {  //還在連線中,接收第一行
    String line = clienthttp.readStringUntil('\n');
    if (line.startsWith("HTTP/1.1 200 OK") ) {
#if defined(DEBUG1) 
      Serial.println(line);
#endif
    }else  if (line == "\r") {
#if defined(DEBUG1) 
      Serial.println("headers received");
#endif
      break;
    }
  }
  while (clienthttp.available()) {
  String line = clienthttp.readStringUntil('\n');
#if defined(DEBUG1) 
  Serial.println(line);
#endif
      if (line.startsWith("{\"state\":\"ok\"")) {
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino httppoststamp state ok successfull!");
#endif
        // Allocate the JSON document
        // Use arduinojson.org/assistant to compute the capacity.
         StaticJsonBuffer<200> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(line);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* message = root["message"]; // "on"
        const char* ts = root["ts"]; // "3"
        const char* encr = root["encr"]; // "6bbb545f010c1d16060957602a870712" 
        String encrStr="ok"+(String)message+(String)ts;
        md5.begin();
        md5.add(encrStr);
        md5.calculate();
#if defined(DEBUG1) 
        Serial.println(F("httppoststamp ok Response:"));
        Serial.println(message);
        Serial.println(ts);
        Serial.println(encr);
#endif
        if(md5.toString().startsWith(encr)){ //編碼正確
#if defined(DEBUG) 
        Serial.println(F("httppoststamp encr ok"));
#endif
           timestamp=String(ts).toInt();  //更新timestamp
           now=millis();
        }
   }
 }
}
 
void poststr(int arrayid, String message){
int i;
byte error=0;
account=(String)ACCOUNT[arrayid];
password=(String)PASSWORD[arrayid];
sid=(String)SENDID[arrayid];
device=(String)DEVICE[arrayid];
company=(String)COMPANY[arrayid];
//time_t httpnow=timestamp;

//clientsecu.setX509Time(httpnow);
httpsconnect();
String url = "/hwang/esp8266/arduino/esp8266lamb.php";
String ts=String(timestamp);
String poststat;
for(i=0; i<MULTI; i++){
  poststat+=String(mystat[i][arrayid]);
}
String saltpass=(char*)saltpassbuf[arrayid];
String encrStr=poststat+sid+device+saltpass+account+message+ts;
md5.begin();
md5.add(encrStr);
md5.calculate();
  String postData = "st="+poststat+"&sid="+sid+"&message="+message+"&ts="+ts+"&device="+device+"&encr="+md5.toString();
#if defined(DEBUG) 
  Serial.print("poststr requesting URL: ");
  Serial.println(url);
  Serial.print("?");
  Serial.println(postData);
#endif

clientsecu.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + https_server+ ":"+ httpsPort + "\r\n" +
               "User-Agent: BuildFailureDetectorESP8266\r\n" +
               "Accept: */*\r\n" +
              "Content-Type: application/x-www-form-urlencoded\r\n" +
               "Content-Length: " + postData.length() + "\r\n" +
               "Connection: close\r\n\r\n");
 clientsecu.print(postData);

#if defined(DEBUG1) 
  Serial.println("poststr request sent");
#endif
  while (clientsecu.connected()) {  //還在連線中,接收第一行
    String line = clientsecu.readStringUntil('\n');
    if (line.startsWith("HTTP/1.1 200 OK") ) {
#if defined(DEBUG1) 
      Serial.println(line);
#endif
    }else  if (line == "\r") {
#if defined(DEBUG) 
      Serial.println("headers received");
#endif
      break;
    }
  }
  while (clientsecu.available()) {
  String line = clientsecu.readStringUntil('\n');
#if defined(DEBUG) 
  Serial.println(line);
#endif
      if (line.startsWith("{\"state\":\"ok\"")) {
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino poststr state ok successfull!");
#endif
        // Allocate the JSON document
        // Use arduinojson.org/assistant to compute the capacity.
         StaticJsonBuffer<200> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(line);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* stateret = root["state"]; // "ok"
        const char* message = root["message"]; // "on"
        const char* ts = root["ts"]; // "3"
        const char* encr = root["encr"]; // "6bbb545f010c1d16060957602a870712" 
        String encrStr=(String)stateret+(String)message+(String)ts+saltpass;
        md5.begin();
        md5.add(encrStr);
        md5.calculate();
#if defined(DEBUG1) 
        Serial.println(F("poststr ok Response:"));
        Serial.println(stateret);
        Serial.println(message);
        Serial.println(ts);
        Serial.println(encr);
#endif
String messageStr=String(message);
        if(md5.toString().startsWith(encr)){ //編碼正確
#if defined(DEBUG) 
        Serial.println(F("encr ok"));
#endif
           timestamp=String(ts).toInt();  //更新timestamp
           now=millis();
#if MULTI>=2
//只有REALY才會有MULTI
int i;
char char1;
            //更新mystat
            if(messageStr.indexOf("off_dly_")==0){  //更新mystat off_dly_1_
               char1=messageStr.charAt(8); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
                mystat[i][0]=3;
            }else if(messageStr.indexOf("off_")==0){  //更新mystat  off_1_
               char1=messageStr.charAt(4); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
                mystat[i][0]=0;
            }else if(messageStr.indexOf('on_dly_')==0){   //更新mystat on_dly_1
               char1=messageStr.charAt(7); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
                mystat[i][0]=2;
            }else if(messageStr.indexOf("on_")==0){   //更新mystat  on_1
               char1=messageStr.charAt(3); //取出第n個RELAY
               i=(byte)char1-0X31; //ARRAY 0 FOR 1 
                mystat[i][0]=1;
            }
#else  // if MULTI>=2
            if(messageStr.indexOf("off_dly")==0){  //含_off_dly更新mystat
                mystat[0][0]=3;
            }else if(messageStr.indexOf("off")==0){  //更新mystat
#ifdef RELAY
              if(mystat[0][arrayid]!=3){       //RELAY在off_dly時會收到off,此時不能改變狀態,否則改了會長滅 
                mystat[0][arrayid]=0;
              }
#else
                mystat[0][arrayid]=0;
#endif  //#ifdef RELAY
            }else if(messageStr.indexOf('on_dly')==0){   //含_on_dly更新mystat
                mystat[0][arrayid]=2;
            }else if(messageStr.indexOf('on_left')==0){   //更新mystat
                mystat[0][arrayid]=3;
            }else if(messageStr.indexOf('on_right')==0){   //更新mystat
                mystat[0][arrayid]=4;
            }else if(messageStr.indexOf('on_for')==0){   //更新mystat
                mystat[0][arrayid]=1;
            }else if(messageStr.indexOf('on_back')==0){   //更新mystat
                mystat[0][arrayid]=2;
            }else if(messageStr.indexOf("on")==0){   //更新mystat
#ifdef RELAY
              if(mystat[0][arrayid]!=2){       //RELAY在on_dly時會收到on,此時不能改變狀態,否則改了會長亮  
                mystat[0][arrayid]=1;
              }
#else
                mystat[0][arrayid]=1;  //RELAYSWITCH,SWITCH改變狀態,可重新感應
#endif  //#ifdef RELAY
            }
#endif  // if MULTI>=2
        }else{
#if defined(DEBUG) 
        Serial.println(F("poststr encr error"));
#endif
        }
      } else if (line.startsWith("{\"state\":\"error")) {
#if defined(DEBUG) 
          Serial.println("esp8266/Arduino poststr state error successfull!");
#endif  // DEBUG3
          // Allocate the JSON document
          // Use arduinojson.org/assistant to compute the capacity.
          StaticJsonBuffer<200> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(line);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("poststr parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* stateret = root["state"]; // "error"
        String message = root["message"]; // "on"
        String ts = root["ts"]; // "3"
#if defined(DEBUG1) 
        Serial.println(F("error Response:"));
        Serial.println(stateret);
        Serial.println(message);
        Serial.println(ts);
#endif
        timestamp=String(ts).toInt(); //有回應ts,就更新timestamp
                   now=millis();
//        if( message.startsWith("on") || message.startsWith("off") ){
          error=1;  //on, off, on_for, on_speed等重要的訊息,錯誤必須重送
//        }
      } else {
#if defined(DEBUG1) 
        Serial.print("esp8266/Arduino poststr last line");
        Serial.println(line);
#endif
      }
    }
#if defined(DEBUG1) 
  Serial.println("poststr closing connection");
#endif
//  if(error){
//       poststr(arrayid,message);
//  }
}

//只是重新計算mytopic1,mytopic2,mytopic3與mytopic4,沒有重新註冊聆聽的topic
void substr(){
int i;
String encrStr;
String subencrStr;
String subscribestr;
String saltpass;
long int timediv=timestamp /300;  //5分鐘更新一次密碼
char subscribechar[88];  //轉換string成char用的buffer
int arrayid;
for (arrayid=0; arrayid< ACCOUNT_NUMBER; arrayid++ ){
saltpass=(char*)saltpassbuf[arrayid];
if ( (timestamp % 300)> 50){//只有開機時(可能在任何時間)會用到
    encrStr=sid+account+saltpass+company+String( timediv );  ///subscribestr的原始字串
#if defined(DEBUG1) 
    Serial.println(encrStr);
#endif
    md5.begin();
    md5.add(encrStr);
    md5.calculate();
#if defined(DEBUG1) 
    Serial.print("md5.toString(encrall): ");
    Serial.println(md5.toString());
#endif 
    subencrStr=md5.toString();
    subscribestr=company+"/"+myacc1[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG1) 
      Serial.println(subscribestr);
#endif 
    mytopic1[arrayid]=subscribestr;
    subscribestr=company+"/"+myacc2[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG) 
      Serial.println(subscribestr);
#endif 
    mytopic3[arrayid]=subscribestr;
    encrStr=sid+account+saltpass+company+ String(timediv+1);
    md5.begin();
    md5.add(encrStr);
    md5.calculate();
#if defined(DEBUG1) 
    Serial.print("md5.toString(encrall): ");
    Serial.println(md5.toString());
#endif
    subencrStr=md5.toString();
    subscribestr=company+"/"+myacc1[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG1) 
      Serial.println(subscribestr);
#endif 
    mytopic2[arrayid]=subscribestr;
    subscribestr=company+"/"+myacc2[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG) 
      Serial.println(subscribestr);
#endif 
    mytopic4[arrayid]=subscribestr;
  }else{ //每5分鐘更新時與開機(可能在任何時間)時會用到
    encrStr=sid+account+saltpass+company+ String( timediv );
#if defined(DEBUG1) 
    Serial.println(encrStr);
#endif
    md5.begin();
    md5.add(encrStr);
    md5.calculate();
    //  Serial.print("md5.toString(encrall): ");
    //  Serial.println(md5.toString());
    subencrStr=md5.toString();
    subscribestr=company+"/"+myacc1[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG1) 
      Serial.println(subscribestr);
#endif
    mytopic1[arrayid]=subscribestr;
    subscribestr=company+"/"+myacc2[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG) 
      Serial.println(subscribestr);
#endif
    mytopic3[arrayid]=subscribestr;
    encrStr=sid+account+saltpass+company+String(timediv-1);  ///subscribestr的原始字串
    md5.begin();
    md5.add(encrStr);
    md5.calculate();
    //  Serial.print("md5.toString(encrall): ");
    //  Serial.println(md5.toString());
    subencrStr=md5.toString();
    subscribestr=company+"/"+myacc1[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG1) 
      Serial.println(subscribestr);
#endif
    mytopic2[arrayid]=subscribestr;
    subscribestr=company+"/"+myacc2[arrayid]+"/comd"+"/"+subencrStr;
#if defined(DEBUG) 
      Serial.println(subscribestr);
#endif
    mytopic4[arrayid]=subscribestr;
  }
}
}

#include <Ticker.h>
Ticker ticker;
//沒有上網時閃爍LED
void tickSer(){
  //toggle state
  static int state = 0;  // get the current state of GPIO1 pin
    state = !state;
#if defined(KEYPAD) || defined(RC) || defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
    digitalWrite(ledpin[0][0], state);  // Turn the LED on by making the voltage LOW
#endif // BUTTON RELAY SWITCH ESP12 WF8266 RC KEYPAD
}

//gets called when WiFiManager enters configuration mode
void configModeCallback (WiFiManager *myWiFiManager) {
  myWiFiManager->setTimeout(60);  //timeout, 90 sec
//  myWiFiManager->setBreakAfterConfig(true);
  Serial.println("Entered config mode with timeout and break");
//  Serial.println(WiFi.softAPIP());
  //if you used auto generated SSID, print it
//  Serial.println(myWiFiManager->getConfigPortalSSID());
  //entered config mode, make led toggle faster
  ticker.attach(0.2, tickSer);
}

void getacc(int arrayid){
byte error=0;
account=(String)ACCOUNT[arrayid];
password=(String)PASSWORD[arrayid];
sid=(String)SENDID[arrayid];
device=(String)DEVICE[arrayid];
company=(String)COMPANY[arrayid];
//time_t httpnow=timestamp;

//clientsecu.setX509Time(httpnow);
httpsconnect();
String url = "/hwang/esp8266/arduino/esp8266getacc.php";
String ts=String(timestamp);
#if MULTI>=2
String poststat=String(mystat[0][arrayid]);
#else
String poststat=String(mystat[0][arrayid]);
#endif
String saltpass=(char*)saltpassbuf[arrayid];
String encrStr=poststat+sid+device+saltpass+account+ts;
md5.begin();
md5.add(encrStr);
md5.calculate();
  String postData = "st="+poststat+"&sid="+sid+"&ts="+ts+"&device="+device+"&encr="+md5.toString();
#if defined(DEBUG)
  Serial.print("getacc requesting URL: ");
  Serial.println(url);
  Serial.print("?");
  Serial.println(postData);
#endif

clientsecu.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + https_server+ ":"+ httpsPort + "\r\n" +
               "User-Agent: BuildFailureDetectorESP8266\r\n" +
               "Accept: */*\r\n" +
              "Content-Type: application/x-www-form-urlencoded\r\n" +
               "Content-Length: " + postData.length() + "\r\n" +
               "Connection: close\r\n\r\n");
 clientsecu.print(postData);

#if defined(DEBUG1) 
  Serial.println("getacc request sent");
#endif
  while (clientsecu.connected()) {  //還在連線中,接收第一行
    String line = clientsecu.readStringUntil('\n');
    if (line.startsWith("HTTP/1.1 200 OK") ) {
#if defined(DEBUG1) 
      Serial.println(line);
#endif
    }else  if (line == "\r") {
#if defined(DEBUG1) 
      Serial.println("getacc headers received");
#endif
      break;
    }
  }
  while (clientsecu.available()) {
  String line = clientsecu.readStringUntil('\n');
#if defined(DEBUG) 
  Serial.println(line);
#endif
      if (line.startsWith("{\"state\":\"ok\"")) {
#if defined(DEBUG1) 
          Serial.println("esp8266/Arduino getacc state ok successfull!");
#endif
        // Allocate the JSON document
        // Use arduinojson.org/assistant to compute the capacity.
         StaticJsonBuffer<250> jsonBuffer;  //要比真正的message多100
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(line);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("getacc parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* stateret = root["state"]; // "ok"
        const char* acc1 = root["acc1"]; // "on"
        const char* acc2 = root["acc2"]; // "on"
        const char* ts = root["ts"]; // "3"
        const char* encr = root["encr"]; // "6bbb545f010c1d16060957602a870712" 
        String encrStr=(String)stateret+(String)acc1+(String)ts+saltpass;
        md5.begin();
        md5.add(encrStr);
        md5.calculate();
#if defined(DEBUG1) 
        Serial.println(encrStr);
        Serial.println(md5.toString());
        
        Serial.println(F("getacc ok Response:"));
        Serial.println(stateret);
        Serial.println(acc1);
        Serial.println(acc2);
        Serial.println(ts);
        Serial.println(encr);
#endif
        if(md5.toString().startsWith(encr)){ //編碼正確
#if defined(DEBUG1) 
            Serial.println(F("getacc encr ok"));
#endif
           timestamp=String(ts).toInt();  //更新timestamp
           now=millis();
           myacc1[arrayid]=acc1;
           myacc2[arrayid]=acc2;
        }else{
#if defined(DEBUG) 
          Serial.println(F("getacc encr error"));
#endif
        }
      } else if (line.startsWith("{\"state\":\"error")) {
#if defined(DEBUG) 
          Serial.println("esp8266/Arduino getacc state error successfull!");
#endif  // DEBUG3
          // Allocate the JSON document
          // Use arduinojson.org/assistant to compute the capacity.
          StaticJsonBuffer<200> jsonBuffer;
          // Parse JSON object
          JsonObject& root = jsonBuffer.parseObject(line);
          // Test if parsing succeeds.
          if (!root.success()) {
#if defined(DEBUG) 
            Serial.println("getacc parseObject() failed");
#endif
            return;
          }
             // Extract values
        const char* stateret = root["state"]; // "error"
        String message = root["message"]; // "on"
        String ts = root["ts"]; // "3"
#if defined(DEBUG1) 
        Serial.println(F("getacc error Response:"));
        Serial.println(stateret);
        Serial.println(message);
        Serial.println(ts);
#endif
        timestamp=String(ts).toInt(); //有回應ts,就更新timestamp
                   now=millis();
//        error=1;  //on, off, on_for, on_speed等重要的訊息,錯誤必須重送
      } else {
#if defined(DEBUG1) 
        Serial.print("esp8266/Arduino getacc last line");
        Serial.println(line);
#endif
      }
    }
#if defined(DEBUG1) 
  Serial.println("getacc closing connection");
#endif
//  if(error){
//       getacc(arrayid);
//  }
}

void setup() {
int i,j;
#if defined(DEBUG) 
  Serial.begin(115200);
  Serial.print("Serial.begin(115200)");
#endif
#if defined(MULTISWITCH)
//  Serial.println("pinMode(outputpin[j][i], OUTPUT)");
  for(j=0; j<MULTI; j++){
    for(i=0; i<ACCOUNT_NUMBER; i++){
        mystat[j][i]=0;
        pinMode(outputpin[j][i], OUTPUT);     // Initialize the outputpin as an output
        pinMode(ledpin[j][i], OUTPUT);     // Initialize the ledpin as an output
        pinMode(inputpin[j][i], INPUT_PULLUP);     // Initialize the inputpin as an input
        digitalWrite(ledpin[j][i], LOW);  // Turn the LED on by making the voltage LOW
        digitalWrite(outputpin[j][i], LOW);  // Turn the relay off by making the voltage LOW
    }
  }
#endif

#if defined(RELAY) || defined(BUTTON) || defined(SWITCH) || defined(RELAYBUTTON) || defined(RELAYSWITCH)
#if MULTI>=2
  for(j=0; j<MULTI; j++){
    for(i=0; i<ACCOUNT_NUMBER; i++){
        mystat[j][i]=0;
        pinMode(outputpin[j][i], OUTPUT);     // Initialize the outputpin as an output
        pinMode(ledpin[j][i], OUTPUT);     // Initialize the ledpin as an output
        pinMode(inputpin[j][i], INPUT_PULLUP);     // Initialize the inputpin as an input
        digitalWrite(ledpin[j][i], LOW);  // Turn the LED on by making the voltage LOW
        digitalWrite(outputpin[j][i], LOW);  // Turn the relay off by making the voltage LOW
    }
//    tickstr[j]="0000000000";
    tickstr="0000000000";
    lastMsg[j] = 0;
  }
#else  //MULTI
    for(i=0; i<ACCOUNT_NUMBER; i++){
        mystat[0][i]=0;
        pinMode(outputpin[0][i], OUTPUT);     // Initialize the outputpin as an output
        pinMode(ledpin[0][i], OUTPUT);     // Initialize the ledpin as an output
        pinMode(inputpin[0][i], INPUT_PULLUP);     // Initialize the inputpin as an input
        digitalWrite(ledpin[0][i], LOW);  // Turn the LED on by making the voltage LOW
        digitalWrite(outputpin[0][i], LOW);  // Turn the relay off by making the voltage LOW
    }
    tickstr="0000000000";
    lastMsg[0] = 0;
#endif  //MULTI
#endif  //RELAY BUTTON SWITCH WF8266 ESP12

#if defined(RC) || defined(KEYPAD)
  pinMode(ledpin[0][0], OUTPUT);     // Initialize the ledpin as an output
  for(i=0; i<16; i++){
    swstate[i]=0;   // Initialize every key state
  }
#endif

#ifdef RCCAR
  initcar();
#endif

#ifdef LEDCLOCK
//init 8 dig 7seg-LED
  lc.shutdown(0,false);
  /* Set the brightness to a medium values */
  lc.setIntensity(0,8);
  /* and clear the display */
  lc.clearDisplay(0);
//no conection
  lc.setChar(0,7,'n',false);
  lc.setChar(0,6,'o',false);
  lc.setChar(0,5,' ',false);
  lc.setChar(0,4,'c',false);
  lc.setChar(0,3,'o',false);
  lc.setChar(0,2,'n',false);
  lc.setChar(0,1,'e',false);
  lc.setChar(0,0,'c',false);
#endif

//建造md5 saltpass
for(j=0; j<ACCOUNT_NUMBER; j++){
  account=(String)ACCOUNT[j];
  password=(String)PASSWORD[j];
  sid=(String)SENDID[j];
  device=(String)DEVICE[j];
  company=(String)COMPANY[j];

  md5.begin();
  md5.add(password);
  md5.calculate();
String tempstr=md5.toString();
#if defined(DEBUG1) 
  Serial.print("encript pass: ");
  Serial.println(tempstr);
#endif
  md5.begin();
  md5.add(tempstr+sid+company);
  md5.calculate();
String saltpass = md5.toString();
#if defined(DEBUG) 
  Serial.print("saltpass: ");
  Serial.println(saltpass);
#endif
  for ( i = 0; i < saltpass.length(); i++) {
#if defined(DEBUG1) 
    Serial.print((char)saltpass[i]);
#endif
    saltpassbuf[j][i]=saltpass[i];
  }
  saltpassbuf[j][i]=0;
}
//準備AP的名稱
String apname="ESTAR"+(String)ACCOUNT[0];
//char charpapname[40];
  for ( i = 0; i < apname.length(); i++) {
#if defined(DEBUG) 
    Serial.print((char)apname[i]);
#endif
    charpapname[i]=apname[i];
  }
  charpapname[i]=0;
  SPIFFS.begin();
#if defined(DEBUG) 
  Serial.println();
  Serial.print("connecting to AP or config AP");
#endif
  WiFi.mode(WIFI_STA);
  //set callback that gets called when connecting to previous WiFi fails, and enters Access Point mode
  wifiManager.setAPCallback(configModeCallback); //flash LED
  wifiManager.setConnectTimeout(30);        //30 sec
  while (WiFi.status() != WL_CONNECTED) {
//沒有connect成功就會進入config mode
    if (!wifiManager.autoConnect(charpapname,PASSWORD[0])){  //改成變數compile成功但執行會出現錯誤
        Serial.println("failed to connect AP, we should reconfig the AP");
        ESP.restart(); //剛燒錄完不能正常restart(),要重新按reset button才會正常restart()
    }
  }
#if defined(DEBUG) 
  Serial.println("");
  Serial.print("WiFi connected get IP address: ");
  Serial.println(WiFi.localIP());
#endif
  ticker.detach();

  //keep LED on
#if defined(RELAY) || defined(BUTTON) || defined(SWITCH) || defined(ESP12) || defined(WF8266) || defined(RC) || defined(KEYPAD)
    digitalWrite(ledpin[0][0], LOW);  // Turn the LED on by making the voltage LOW
#endif //BUTTON RELAY SWITCH ESP12 WF8266 RC KEYPAD

    httppoststamp();  // 更新timestamp
#if defined(DEBUG) 
  Serial.print("Waiting for NTP time sync: ");
#endif
  int numCerts = certs.initCertStore(&certs_idx, &certs_ar); // Generate certs.idx
#if defined(DEBUG) 
  Serial.printf("Number of CA certs read: %d\n", numCerts);
#endif
  if (numCerts == 0) {
#if defined(DEBUG) 
      Serial.printf("No certs found. Did you run certs-from-mozill.py and upload the SPIFFS directory before running?\n");
#endif
      return; // Can't connect to anything w/o certs!
  }
  clientsecu.setCertStore(&certs);
    for(i=0; i< ACCOUNT_NUMBER; i++){
        getacc(i); //必須再https之後才能取得mqtt存取碼,也會取得timestamp
    }    
    substr();  //還沒取得mytopic//timestamp成功後,修改subscribe topic
    clientmqtt.setServer(mqtt_server, 1883);
#if !defined(RC)  //加速遙控器
        clientmqtt.setCallback(callback);  //加速遙控器不必聆聽訊息
#endif
//#if defined(RELAY) || defined(BUTTON) ||defined(SWITCH) ||defined(RCCAR) ||defined(RC) ||defined(KEYPAD) 
    reconnectmqtt(0);   //遙控器也要發送mqtt訊息
//#endif
}  // setup()

void mqttsend(int arrayid, String message) {
int i,j;
String encrStr;
String subscribestr;
String messagestr;
String saltpass=(char*)saltpassbuf[arrayid];
long int timediv=timestamp /300;  //5分鐘更新一次密碼
char subscribechar[88];  //topic轉換string成char用的buffer
char messagechar[208];   //message轉換string成char用的buffer

account=(String)ACCOUNT[arrayid];
sid=(String)SENDID[arrayid];
company=(String)COMPANY[arrayid];
if(!clientmqtt.connected()){
  reconnectmqtt(arrayid);  //mqtt connect
}
#if defined(DEBUG) 
      Serial.print("mqttsend()");
      Serial.print(arrayid);
      Serial.println("): mqtt connected");
#endif
       // ...  resubscribe
String sendtopic;
  encrStr=sid+account+saltpass+company+String( timediv );  ///subscribestr的原始字串
#if defined(DEBUG1) 
    Serial.println(encrStr);
#endif
  md5.begin();
  md5.add(encrStr);
  md5.calculate();
#if defined(DEBUG1) 
    Serial.print("md5.toString(encrall): ");
    Serial.println(md5.toString());
#endif
  subscribestr=md5.toString();
  sendtopic=company+"/"+myacc1[arrayid]+"/comd"+"/"+subscribestr+"/"+String(timestamp);

      for ( i = 0; i < sendtopic.length(); i++) {
#if defined(DEBUG1) 
        Serial.print((char)sendtopic[i]);
#endif
        subscribechar[i]=(char)sendtopic[i];
      }
      subscribechar[i]=0; //備妥sendtopic
#if defined(DEBUG1) 
      Serial.println();
#endif
String mqtt_encr;
String mqtt_aes;
    encrStr=sid+message+sid+(String)timestamp+saltpass;
  md5.begin();
  md5.add(encrStr);
  md5.calculate();
    mqtt_encr=md5.toString();
    mqtt_aes="{\"state\":\"ok\",\"ts\":\""+(String)timestamp+"\",\"sid\":\""+sid+"\",\"rid\":\""+sid+"\",\"msg\":\""+message+"\"}";
//prepare key and iv, set key=saltpassbuf iv=mqtt_encr
    setkeyiv(arrayid, mqtt_encr);
  // encrypt
  int length = mqtt_aes.length(); 
  char plain_text[length];
      for ( i = 0; i < mqtt_aes.length(); i++) {
#if defined(DEBUG) 
        Serial.print((char)mqtt_aes[i]);
#endif
        plain_text[i]=(char)mqtt_aes[i];
      }
      plain_text[i]=0; //備妥aes char buffer
  
  bufferSize(plain_text, length);
  char encrypted[length];
  encrypt(plain_text, encrypted, length);
#if defined(DEBUG) 
  Serial.print("Encrypted length: ");
  Serial.println(length);
  Serial.print("Encrypted: ");
  Serial.println(encrypted);
#endif
/********/
      j=strlen(encrypted);
      if(j>88 && j<100)
        j=88;    //108 is a special number for the on off case
      else if(j>108 && j<116)
        j=108;    //128 is a special number for the on_dly180 off_dly180 case
      else if(j>116 && j<130)
        j=128;    //128 is a special number for the on_dly180 off_dly180 case
      else if(j>136 && j<150)
        j=148;    //148 is a special number for the on_dly180 off_dly180 case
      for ( i = 0; i < j; i++) {  
#if defined(DEBUG1) 
        Serial.print((char)encrypted[i]);
#endif
        messagechar[i]=(char)encrypted[i];
      }
      messagechar[i]=0;  //備妥message
    messagestr="{\"state\":\"aes\",\"aes\":\""+(String)messagechar+"\",\"encr\":\""+mqtt_encr+"\"}";
/***********/
//    messagestr="{\"state\":\"aes\",\"aes\":\""+(String)encrypted+"\",\"encr\":\""+mqtt_encr+"\"}";
      for ( i = 0; i < messagestr.length(); i++) {
#if defined(DEBUG) 
        Serial.print((char)messagestr[i]);
#endif
        messagechar[i]=(char)messagestr[i];
      }
      messagechar[i]=0;  //備妥message
#if defined(DEBUG) 
      Serial.println();
#endif
      clientmqtt.publish(subscribechar, messagechar);  
}

byte padstate;
byte timeinv;
void loop() {
int i;
String  sid;

  if(millis()-now >= 50 ){ //指示燈顯示目前狀態,off才會滅掉,因此on會常亮
#if  defined(RC) || defined(KEYPAD)  //汽車遙控器不會有MULTI,RC與KEYPAD只有一個LED用來顯示按鍵是否按下
    if(padstate==0 ){  //0=off 
        digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
    }
#endif
#if  defined(RELAY) || defined(RELAYSWITCH) || defined(RELAYBUTTON) || defined(LEDCLOCK) || defined(SWITCH) || defined(BUTTON)
  for(i=0; i<MULTI; i++){  //修正每一個RELAY的LED指示燈
    if(mystat[i][0]==0 || mystat[i][0]==3){  //0=off 3=off_dly
#if defined(ESP12) || defined(WF8266) || defined(SONOFF)
      digitalWrite(ledpin[i][0], HIGH);  // Turn the LED off by making the voltage HIGH
#endif
    }
  }
#endif   //#if  defined(RELAY) || defined(RELAYSWITCH) || defined(RELAYBUTTON) || defined(LEDCLOCK) || defined(SWITCH) || defined(BUTTON)
  } //  if(millis()-now>=50 ){ //指示燈顯示目前狀態,off才會滅掉,因此on,on_dly會常亮
  
      if( (millis()+1000) < 1000){
//時間逆轉
          timeinv=1;      
      }else{
          timeinv=0;      
      }
  if(( millis()-now ) >= 1000 && timeinv==0){  //每經過1秒
      flashon=0;
      if(start==0 && timestamp%3==0){//剛開機,若無法正確連線,每3秒連線一次
//剛開機
#if defined(DEBUG) 
        Serial.print("Start");
        Serial.println(timestamp);
#endif
//        httppoststamp();  //取得timestamp
//        poststr(0,"poll");  //不會被遙控動作的都用poll,也會取得timestamp
        if(timestamp >10000){  //連線成功,對時成功
            start=1;
//            for(i=0; i< ACCOUNT_NUMBER; i++){
//                getacc(i); //取得mqtt存取碼,也會取得timestamp
//            }
//            substr();  //修改subscribe topic//遙控器發mqtt也需要有topic
#ifdef RCCAR
           carstop();
#endif
//            clientmqtt.setServer(mqtt_server, 1883);
#if !defined(RC) && !defined(KEYPAD) && !defined(MULTISWITH)  //遙控器,KEYPAD 有免除
//            clientmqtt.setCallback(callback);    //免除callback以加速,遙控器,不必聆聽訊息
#endif
#if defined(RELAY) || defined(BUTTON) ||defined(SWITCH) ||defined(RCCAR) ||defined(RC) ||defined(KEYPAD) 
//    reconnectmqtt(0);   //遙控器也要發送mqtt訊息
#endif
        }  //if(timestamp >10000){  //連線成功,對時成功
        now=millis(); //連線成功開始計時
#if defined(RCCAR) || defined(RELAY) || defined(SWITCH) || defined(BUTTON)       //只有會動作能遙控的才用hello,避免影響relay狀態
            poststr(0,"hello");  //報告server剛開機server都設為off
#else
#if !(defined(RC) || defined(KEYPAD)) //RC,KEYPAD 有免除
            for(i=0; i< ACCOUNT_NUMBER; i++){
                poststr(i,"poll");  //不會被遙控動作的都用poll
            }
#endif   //#ifndef RC
#endif   // RCCAR || RELAY
    } else { // if(start==0 && timestamp%3==0){//剛開機,若無法正確連線,每3秒連線一次
      now += 1000;
      timestamp++;  //連線成功自動對時,平常每秒加1
  while (WiFi.status() != WL_CONNECTED) {
//會進到reconnectmqtt(),但不會進到這裡
    wifiManager.setAPCallback(configModeCallback);
    wifiManager.setConnectTimeout(30);        //30 sec
//沒有connect成功就會進入config mode
    if (!wifiManager.autoConnect(charpapname,PASSWORD[0])){  //改成變數compile成功但執行會出現錯誤
        Serial.println("loop failed to connect AP, we should reconfig the AP");
        ESP.restart(); //剛燒錄完不能正常restart(),要重新按reset button才會正常restart()
    }
//連線成功
    httppoststamp();  // 更新timestamp
    for(i=0; i< ACCOUNT_NUMBER; i++){
        getacc(i); //必須再https之後才能取得mqtt存取碼,也會取得timestamp
    }    
    substr();  //還沒取得mytopic//timestamp成功後,修改subscribe topic
  }

      for(i=0; i < ACCOUNT_NUMBER; i++){    
          sid=(String)SENDID[i];
          if (((timestamp % 1800)== (sid.toInt() %1800))) { //每隔半小時更新mqtt存取碼,分散負載
            getacc(i);   //取得mqtt存取碼
          }
      }
      if (((timestamp % 150)== 0)) { //每隔2.5分鐘更新連線存取碼
        substr();   //修改subscribe topic//加速遙控器
      }
/************
//遙控車不必回報以免造成速度太慢
#if defined(RCCAR) 
      if(mystat[0]==0){
        poststr(0,"hello_off");      //報告狀況同時做網路對時
      }else if(mystat[0]==1){
        poststr(0,"hello_on_for");   //報告狀況同時做網路對時
      }else if(mystat[0]==3){
        poststr(0,"hello_on_left");  //報告狀況同時做網路對時
      }else if(mystat[0]==2){
        poststr(0,"hello_on_back");  //報告狀況同時做網路對時
      }else if(mystat[0]==4){
        poststr(0,"hello_on_right"); //報告狀況同時做網路對時
      }
#endif
/*****************************/
#if defined(KEYPAD) || defined(RC) || defined(MULTISWITCH) || defined(RELAYBUTTON) || defined(RELAYSWITCH) || defined(LEDCLOCK) //附屬裝置
//Serial.println("(timestamp % 300)==(sid.toInt() %300)");
    for(int i=0; i<ACCOUNT_NUMBER; i++){  //檢查是否報告每個RELAY的狀況
        sid=(String)SENDID[i];
        if((timestamp % 300)==(sid.toInt() %300)){  //每隔5分鐘連線對時一次,並報告狀況,分散負載
            poststr(i,"poll");      //附屬裝置只能檢查狀況,不然會影響主裝置狀態,同時做網路對時
        }
    }
#endif //#if defined(KEYPAD) || defined(RC) || defined(MULTISWITCH) || defined(RELAYBUTTON) || defined(RELAYSWITCH) || defined(LEDCLOCK) //附屬裝置

#if defined(RELAY) || defined(SWITCH) || defined(BUTTON)  //獨立裝置
#if MULTI>=2 || ACCOUNTNUMBER==1
    for(int i=0; i<MULTI; i++){      //報告每個RELAY的狀況
      if(mystat[i][0]==0){
        poststr(i,"hello_off");      //報告狀況同時做網路對時
      }else if(mystat[i][0]==1){
        poststr(i,"hello_on");       //報告狀況同時做網路對時
      }else if(mystat[i][0]==3){
        poststr(i,"hello_off_dly");  //報告狀況同時做網路對時
      }else if(mystat[i][0]==2){
        poststr(i,"hello_on_dly");   //報告狀況同時做網路對時
      }
    }
#else   // MULTI>=2 && ACCOUNTNUMBER==1
      for(int i=0; i<ACCOUNT_NUMBER; i++){    //報告每個RELAY的狀況
          sid=(String)SENDID[i];
          if((timestamp % 300)==(sid.toInt() %300)){  //每隔5分鐘連線對時一次,並報告狀況,分散負載
              if(mystat[0][i]==0){
                poststr(i,"hello_off1");      //報告狀況同時做網路對時
              }else if(mystat[0][i]==1){
                poststr(i,"hello_on");        //報告狀況同時做網路對時
              }else if(mystat[0][i]==3){
                poststr(0,"hello_off_dly");   //報告狀況同時做網路對時
              }else if(mystat[0][i]==2){
                poststr(i,"hello_on_dly");   //報告狀況同時做網路對時
              }
          }
      }
#endif  //MULTI>=2 && ACCOUNTNUMBER==1
#endif  //RELAY SWITCH BUTTON

#if defined(RC) || defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
  for(i=0; i<MULTI; i++){
    if(mystat[i][0]==1){
#if defined(DEBUG) 
      Serial.println("ledon");
#endif
    }
    digitalWrite(ledpin[i][0], LOW);  // Turn the LED on by making the voltage LOW
  }
#endif  //#if defined(RC) || defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
    }  // if(millis()-now>=1000){  //每經過1秒
    
#if defined(DEBUG) 
    Serial.print("Seconds since Jan 1 1900 = ");
    Serial.println(timestamp);
#endif
unsigned long epoch =timestamp;
#ifdef LEDCLOCK
//init 8 dig 7seg-LED
    lc.shutdown(0,false);
    /* Set the brightness to a medium values */
    lc.setIntensity(0,8);
    /* and clear the display */
    lc.clearDisplay(0);
    if(epoch % 15 < 11){  //0~10秒顯示時間
         lc.setDigit(0,0,tm.tm_sec%10,false);
         lc.setDigit(0,1,(tm.tm_sec)/10,false);
         lc.setChar(0,2,'-',false);
         lc.setDigit(0,3,tm.tm_min%10,false);
         lc.setDigit(0,4,(tm.tm_min)/10,false);
         lc.setChar(0,5,'-',false);
         lc.setDigit(0,6,tm.tm_hour%10,false);
         if((tm.tm_hour)/10==0){
            lc.setDigit(0,7,' ',false);
         } else{
            lc.setDigit(0,7,(tm.tm_hour)/10,false);
         }
    }else{   //11~14秒顯示日期
         lc.setDigit(0,0,tm.tm_mday%10,true);
         if((tm.tm_mday)/10==0){
            lc.setDigit(0,1,' ',false);
         } else{
            lc.setDigit(0,1,(tm.tm_mday)/10,false);
         }
         lc.setDigit(0,2,(tm.tm_mon+1)%10,true);
         if((tm.tm_mon+1)/10==0){
            lc.setDigit(0,3,' ',false);
         } else{
            lc.setDigit(0,3,(tm.tm_mon+1)/10,false);
         }
         lc.setDigit(0,4,(tm.tm_year+1900)%10,true);
         lc.setDigit(0,5,((tm.tm_year+1900)/10)%10,false);
         lc.setDigit(0,6,((tm.tm_year+1900)/100)%10,false);
         lc.setDigit(0,7,(tm.tm_year+1900)/1000,false);
    }
#endif
    // print the hour, minute and second:
  if ((epoch % 5) == 0) {
#if defined(ACTIVEHIGHSENSOR) 
    sensortimes=0;
#endif
  }
  if ((epoch % 2) == 0) {
#if defined(RC) || defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
  for(i=0; i<MULTI; i++){
    if(mystat[i][0]==1){
#if defined(DEBUG) 
      Serial.print(i);
      Serial.println(" ledon");
#endif
    }
  }
#endif  //#if defined(RC) || defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
    }
  }

// switch detect
#if defined(RELAYSWITCH) || defined(SWITCH)
#if defined(ACTIVEHIGHSENSOR) 
  if( digitalRead(inputpin[0][0])==0 ){ //感應器輸出0為off
#else // #if defined(ACTIVEHIGHSENSOR) 
  if( digitalRead(inputpin[0][0]) ){ //開關接地為on
#endif  //  #if defined(ACTIVEHIGHSENSOR) 
//sw目前在off的位置
    if( swstate[0]==1){  //sw上一次為on,有改變
          swstate[0]=0;  //改設為off,避免再進入
#if defined(ACTIVEHIGHSENSOR) 
      if( mystat[0][0]==1){ //sensor只有開或關時才會重新感應，RELAYSWITCH在on_dly後等到poll得到on,才能重新感應
                         //SWITCH在on_dly後是用hello_on_dly不會得到on,將無法重新感應
#else        
      if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
#endif
        mystat[0][0]=0;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#if defined(ACTIVEHIGHSENSOR) 
//          mqttsend(0,"on_dly180");  //感應器off不處理,時間到自然off
//          poststr(0,"on_dly180"); //180秒後滅(延遲180秒滅)  會改變mystat[0]=2
#else
          mqttsend(0,"off");
#if ACCOUNT_NUMBER >= 2    //一個開關控制2個遙控插座
          mqttsend(1,"off");  // second lamb
          poststr(1,"off");   // second lamb
#endif
          poststr(0,"off");
#endif    //#if defined(ACTIVEHIGHSENSOR) 
        }//  if( mystat[0]==1){
      }else {    //    if( swstate[0]==1){  //sw目前是off,上一次為on,有改變    //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
          swstate[0]=0;
          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }   //if( swstate[0]==1){ //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
   }else{   // if( digitalRead(inputpin[0])==0 )
//sw目前在on的位置
    if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
//        swstate[0]=1;    //根據sw目前在on的位置改變,
#if defined(ACTIVEHIGHSENSOR) 
      sensortimes++;
#if defined(DEBUG1)
      if(( sensortimes % 10000 )==0){
          Serial.print(sensortimes);
          Serial.print(", on det");
      }
#endif
      if( sensortimes > 100000 ){  //sensor要維持5秒才不是雜訊
          swstate[0]=1;    //根據sw目前在on的位置改變,但sensor要5秒才不是雜訊
          sensortimes=0;
          if( mystat[0][0]==0){  //sensor只有開或關時才會重新感應
#else // #if defined(ACTIVEHIGHSENSOR) 
          swstate[0]=1;    //根據sw目前在on的位置改變
          if( mystat[0][0]==0 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
#endif  //#if defined(ACTIVEHIGHSENSOR) 
//sw目前在on的位置
          mystat[0][0]=1;  //隨著現在sw狀況改變
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
#if defined(ACTIVEHIGHSENSOR) 
//          mqttsend(0,"off_dly172800");   //感應到就2天後亮
//          mqttsend(0,"on_dly180");    //感應到就亮3分鐘
          poststr(0,"on_dly180");     //感應到就亮3分鐘後滅(延遲180秒滅)  會改變mystat[0][0]=2
#if defined(DEBUG)
          Serial.println("detected on");
#endif
      }     //  if( mystat[0][0]==0){  //sensor只有開或關時才會重新感應
     }      //  if(sensortimes>100)｛
#else   //  #if defined(ACTIVEHIGHSENSOR)
          mqttsend(0,"on");
#if ACCOUNT_NUMBER >= 2  //一個開關控制2個遙控插座
          mqttsend(1,"on");   // second lamb
          poststr(1,"on");    // second lamb
#endif
          poststr(0,"on");
      }     //  if( mystat[0][0]==0){  //sensor只有開或關時才會重新感應
#endif   //  #ifdef ACTIVEHIGHSENSOR
   }else{    // if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
//sw目前在on的位置,,上一次也為on,沒有改變
          swstate[0]=1;
          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
   }         //if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
#if defined(ACTIVEHIGHSENSOR) 
//sensor目前在on的位置檢查是否還在dly中
      if(lastMsg[0]-timestamp <60){ //sensor只有開或關時才會重新感應,或者等到還有60秒才時間到,sensor開始偵測
      sensortimes++;
#if defined(DEBUG1)
      if(( sensortimes % 10000 )==0){
          Serial.print(sensortimes);
          Serial.print(", lastMsg det");
      }
#endif
      if(sensortimes > 100000){  //sensor要維持5秒才不是雜訊
          sensortimes=0;
          mystat[0][0]=2;
          swstate[0]=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
//          mqttsend(0,"on_dly180");   //感應到就亮3分鐘
          poststr(0,"on_dly180");    //感應到就亮3分鐘後關掉(延遲3分鐘關掉)
//          mqttsend(0,"off_dly172800");   //感應到就2天後亮
      }
     }          // if(lastMsg-now <60){
#endif   //#ifdef ACTIVEHIGHSENSOR
}         // if( digitalRead(inputpin[0])==0 )
#endif  //  #if defined(RELAYSWITCH) || defined(SWITCH)

// multi switch detect
#if defined(MULTISWITCH)
//  Serial.println("digitalRead(inputpin[0][0])");
  if( digitalRead(inputpin[0][0]) ){ //開關接地為on
//sw目前在off的位置
    if( swstate[0]==1){  //sw上一次為on,有改變
          swstate[0]=0;  //改設為off,避免再進入
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"off");
          mqttsend(1,"off");  // second lamb
          poststr(0,"off");
          poststr(1,"off");   // second lamb
      }else {    //    if( swstate[0]==1){  //sw目前是off,上一次為on,有改變    //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
          swstate[0]=0;
          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }   //if( swstate[0]==1){ //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
   }else{   // if( digitalRead(inputpin[0])==0 )
//sw目前在on的位置
    if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
        swstate[0]=1;    //根據sw目前在on的位置改變,
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on");
          poststr(0,"on");
          mqttsend(1,"on");   // second lamb
          poststr(1,"on");    // second lamb
     }else{    // if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  //sw目前在on的位置,,上一次也為on,沒有改變
            swstate[0]=1;
            digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
     }         //if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  }         // if( digitalRead(inputpin[0])==0 )
  if( digitalRead(inputpin[1][0]) ){ //開關接地為on
//sw目前在off的位置
    if( swstate[1]==1){  //sw上一次為on,有改變
          swstate[1]=0;  //改設為off,避免再進入
          digitalWrite(ledpin[1][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(1,"off");
          mqttsend(2,"off");  // second lamb
          poststr(1,"off");
          poststr(2,"off");   // second lamb
      }else {    //    if( swstate[0]==1){  //sw目前是off,上一次為on,有改變    //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
          swstate[1]=0;
          digitalWrite(ledpin[1][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }   //if( swstate[0]==1){ //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
   }else{   // if( digitalRead(inputpin[0])==0 )
//sw目前在on的位置
    if( swstate[1]==0){  //sw目前在on的位置,上一次為off,有改變
        swstate[1]=1;    //根據sw目前在on的位置改變,
          digitalWrite(ledpin[1][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          poststr(1,"on");
          poststr(2,"on");    // second lamb
          mqttsend(1,"on");
          mqttsend(2,"on");   // second lamb
     }else{    // if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  //sw目前在on的位置,,上一次也為on,沒有改變
            swstate[1]=1;
            digitalWrite(ledpin[1][0], HIGH);  // Turn the LED off by making the voltage HIGH
     }         //if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  }         // if( digitalRead(inputpin[0])==0 )
  if( digitalRead(inputpin[2][0]) ){ //開關接地為on
//sw目前在off的位置
    if( swstate[2]==1){  //sw上一次為on,有改變
          swstate[2]=0;  //改設為off,避免再進入
          digitalWrite(ledpin[2][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"off");
          mqttsend(2,"off");  // second lamb
          mqttsend(1,"off");  // second lamb
          poststr(1,"off");
          poststr(0,"off");
          poststr(2,"off");   // second lamb
      }else {    //    if( swstate[0]==1){  //sw目前是off,上一次為on,有改變    //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
          swstate[2]=0;
          digitalWrite(ledpin[2][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }   //if( swstate[0]==1){ //  if( mystat[0][0]==1 || mystat[0][0]==2 || mystat[0][0]==3 ){ //on_dly, off_dly時要能開關
   }else{   // if( digitalRead(inputpin[0])==0 )
//sw目前在on的位置
    if( swstate[2]==0){  //sw目前在on的位置,上一次為off,有改變
        swstate[2]=1;    //根據sw目前在on的位置改變,
          digitalWrite(ledpin[2][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on");
          mqttsend(2,"on");   // second lamb
          mqttsend(1,"on");   // second lamb
          poststr(1,"on");
          poststr(0,"on");
          poststr(2,"on");    // second lamb
     }else{    // if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  //sw目前在on的位置,,上一次也為on,沒有改變
            swstate[2]=1;
            digitalWrite(ledpin[2][0], HIGH);  // Turn the LED off by making the voltage HIGH
     }         //if( swstate[0]==0){  //sw目前在on的位置,上一次為off,有改變
  }         // if( digitalRead(inputpin[0])==0 )
#endif  //  #if defined(RELAYSWITCH) || defined(SWITCH)

#if defined( ONBOARDSWITCH ) 
#ifdef ACTIVEHIGHSENSOR
        if( mystat[0][0]==0 ){//感應器原本在off的位置
  if( digitalRead(inputpin[0][0]) ){ //感應器high為on
#else
  if( digitalRead(inputpin[0][0])==0 ){ //接地為on
#endif
//sw目前在on的位置
    if( swstate[0]==0){   //sw原本在off的位置
        swstate[0]=1;     //sw有改變狀態為on
#if defined(ACTIVEHIGHSENSOR) 
        if( mystat[0][0]==0 ){//感應器原本在off的位置
#else
        if( mystat[0][0]==0 || mystat[0][0]==2 || mystat[0][0]==3){//繼電器原本在off的位置
#endif
          mystat[0][0]=1;    //改繼電器成吻合on的狀態
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          digitalWrite(outputpin[0][0], HIGH);   // Turn the reaky off
#if defined(DEBUG)
          Serial.println("on");
#endif
          poststr(0,"hello_on"); //立即報告狀態,讓網頁能及時反應
        }
      }else{    //   if( swstate[0]==0){   //sw原本在off的位置
          swstate[0]=1;
//          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }
    delay(50);
  }else{
//sw目前在off的位置
      if( swstate[0]==1){  //sw原本在on的位置
        swstate[0]=0;    //改變sw狀態
#if defined(ACTIVEHIGHSENSOR)
#if MULTI>=2
        if( mystat[0][0]==1){ //繼電器原本在on的位置
#if defined(DEBUG)
          Serial.println("off");
#endif
         mystat[0][0]=2;
         mytick=300;   //on_dly 300
         digitalWrite(outputpin[0][0], HIGH);   // Turn the relay on (Note that LOW is the voltage level
         digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          poststr(0,"hello_on_dly"); //立即報告狀態,讓網頁能及時反應
#else   //#if MULTI>=2
        if( mystat[0][0]==1){ //繼電器原本在on的位置
#if defined(DEBUG)
          Serial.println("off");
#endif
         mystat[0][0]=2;
         tickstr="300";
         mytick=300;  //on_dly 300
         digitalWrite(outputpin[0][0], HIGH);   // Turn the relay on (Note that LOW is the voltage level
         digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          poststr(0,"hello_on_dly"); //立即報告狀態,讓網頁能及時反應
#endif   //#if MULTI>=2
#else  //#if defined(ACTIVEHIGHSENSOR)
        if( mystat[0][0]==1){ //繼電器原本在on的位置
#if defined(DEBUG)
          Serial.println("off");
#endif
          mystat[0][0]=0;     //改變繼電器狀態 off
          digitalWrite(ledpin[0][0], HIGH);   // Turn the LED off (Note that LOW is the voltage level
          digitalWrite(outputpin[0][0], LOW);   // Turn the relay off
          poststr(0,"hello_off"); //立即報告狀態,讓網頁能及時反應
#endif   //#if defined(ACTIVEHIGHSENSOR)
        }
      }else{  //sw原本就在off的位置
          swstate[0]=0;
//          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
      }
    delay(50);
  }
#endif  // ONBOARDSWITCH

// button detect
#if defined(RELAYBUTTON) || defined(BUTTON)
  if(digitalRead(inputpin[0][0])==0 ){
//BUTTON在按下的位置
    if( swstate[0]==1){
//BUTTON狀態原來為放開
      swstate[0]=0;       //改變BUTTON狀態為按下
      if( mystat[0][0]==0){  //繼電器原本在off的位置
          mystat[0][0]=1;    //改變繼電器狀態為on
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on");  //MULTI時on_1為開啟第1個relay,on_2為開啟第2個relay,
          poststr(0,"on");  //MULTI時on_1為開啟第1個relay,on_2為開啟第2個relay,
      }else{
          mystat[0][0]=0;  //改變繼電器狀態為off
          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
          mqttsend(0,"off");  //MULTI時on_1為開啟第1個relay,on_2為開啟第2個relay,
          poststr(0,"off"); //MULTI時off_1為關閉第1個relay,off_2為關閉第2個relay,
      }
   }
   //BUTTON狀態原來為壓下
    delay(10);
  }else{
//BUTTON在放開的位置
    delay(100); //避開放開時彈跳的時間
    swstate[0]=1;//改變BUTTON狀態為放開
  }
#endif  //RELAYBUTTON  BUTTON

#if defined(ONBOARDBUTTON)
//#if  MULTI>=2 還沒實作
  if(digitalRead(inputpin[0][0])==0 ){
//BUTTON在按下的位置
    if( swstate[0]==1){
 //BUTTON狀態原來為放開
      swstate[0]=0;     //改變BUTTON狀態為按下
      if( mystat[0][0]==0){ //繼電器原本在off的位置
          mystat[0][0]=1;   //改變繼電器狀態為on
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          digitalWrite(outputpin[0][0], HIGH);   // Turn the relay on
          poststr(0,"hello_on_change"); //立即報告狀態,讓網頁能及時反應
      }else{
          mystat[0][0]=0;  //改變繼電器狀態為off
          digitalWrite(ledpin[0][0], HIGH);  // Turn the LED off by making the voltage HIGH
          digitalWrite(outputpin[0][0], LOW);   // Turn the relay off
          poststr(0,"hello_off_change"); //立即報告狀態,讓網頁能及時反應
      }
   }
//BUTTON狀態原來為壓下
    delay(10);
  }else{
//BUTTON在放開的位置
    delay(100);  //避開放開時彈跳的時間
    swstate[0]=1;//改變BUTTON狀態為放開
  }
#endif   //#if defined(ONBOARDBUTTON)

  if (!clientmqtt.connected() ) {
      reconnectmqtt(0);
      substr();   //修改subscribe topic //遙控器也要發mqtt訊息
  }
  clientmqtt.loop(); //MQTT掃描

//以下為on_dly與off_dly的處理
//#if  defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(ESP12) || defined(WF8266)
#if  defined(BUTTON) || defined(RELAY) || defined(SWITCH) || defined(RELAYBUTTON) || defined(RELAYSWITCH) || defined(ONBOARDBUTTON) || defined(ONBOARDSWITCH)
#if MULTI>=2
for(int i=0; i<MULTI; i++){
//  mytick=tickstr[i].toInt();  //收到的訊息
  mytick=tickstr.toInt();  //收到的訊息
  if(mytick != 0){
    lastMsg[i] = timestamp + mytick;   //計算時間到的tick
//    tickstr[i]="00000000";
    tickstr="00000000";
  }
  if(mystat[i][0]==2){   //on_dly
    long now = millis();
    if (long(timestamp - lastMsg[i]) > 0) {  //time up
#ifdef DEBUG1
    Serial.print("on_dly off i, timestamp , lastMsg[0] :");
    Serial.print(i);
    Serial.print(", ");
    Serial.print(timestamp);
    Serial.print(", ");
    Serial.println(lastMsg[0]);
#endif
#ifdef RELAY
      poststr(0,"off");  //同步其他裝置
#endif
      mystat[i][0]=0;
      digitalWrite(outputpin[i][0], LOW);   // Turn the relay off
      digitalWrite(ledpin[i][0], HIGH);   // Turn the LED off (Note that LOW is the voltage level
    }
  }else  if(mystat[i][0]==3){  //off_dly  現在是off時間到變on
    long now = millis();
    if (long (timestamp - lastMsg[i]) > 0) {  //time up
#ifdef DEBUG1
    Serial.print("off_dly on i, timestamp , lastMsg[0] :");
    Serial.print(i);
    Serial.print(timestamp);
    Serial.print(", ");
    Serial.println(lastMsg[0]);
#endif
#ifdef RELAY
      poststr(0,"on");  //同步其他裝置
#endif
      mystat[i][0]=1;  //relay state
      digitalWrite(outputpin[i][0], HIGH);   // Turn the relay on
      digitalWrite(ledpin[i][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
    }
  }
}
#else  //MULTI
  mytick=tickstr.toInt();
  if(mytick != 0){
    lastMsg[0] = timestamp + mytick;
    tickstr="00000000";
    value=mytick;
  }
  if(mystat[0][0]==2){   //on_dly
    long now = millis();
    if (long (timestamp - lastMsg[0]) > 0) {  //time up
#ifdef DEBUG1
    Serial.print("on_dly off timestamp , lastMsg[0] :");
    Serial.print(timestamp);
    Serial.print(", ");
    Serial.println(lastMsg[0]);
#endif
#ifdef RELAY
      poststr(0,"off");  //同步其他裝置
#endif
//      value=0;
      mystat[0][0]=0;
      digitalWrite(outputpin[0][0], LOW);   // Turn the relay off
      digitalWrite(ledpin[0][0], HIGH);   // Turn the LED off (Note that LOW is the voltage level
    }
  }else  if(mystat[0][0]==3){  //off_dly
    long now = millis();
    if (long(timestamp - lastMsg[0]) > 0) {  //time up
#ifdef DEBUG1
    Serial.print("off_dly on timestamp , lastMsg[0] :");
    Serial.print(timestamp);
    Serial.print(", ");
    Serial.println(lastMsg[0]);
#endif
#ifdef RELAY
      poststr(0,"on");  //同步其他裝置
#endif
//      value=0;
      mystat[0][0]=1;  //relay state
      digitalWrite(outputpin[0][0], HIGH);   // Turn the relay on
      digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
    }
  }
#endif  //MULTI
#endif //BUTTON RELAY SWITCH ESP12 WF8266

#ifdef RC
char customKey;
  customKey = customKeypad.getKey();
  if (customKey){
#ifdef DEBUG1
    Serial.println("RC get customKey");
#endif
    if(customKey=='1' ){
        if( padstate==0){
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on_for");
//          poststr(0,"on_for");
          mystat[0][0]=1;
#ifdef DEBUG
    Serial.println("RC on_for");
#endif
        }
    }else  if(customKey=='5' ){
        if( padstate==0){
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"off");
//             poststr(0,"off");
       mystat[0][0]=0;
#ifdef DEBUG
    Serial.println("RC off");
#endif
        }
    }else  if(customKey=='4' ){
        if( padstate==0){
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on_left");
//          poststr(0,"on_left");
          mystat[0][0]=3;
#ifdef DEBUG
    Serial.println("RC on_left");
#endif
        }
    }else  if(customKey=='6' ){
        if( padstate==0){
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on_right");
//          poststr(0,"on_right");
          mystat[0][0]=4;
#ifdef DEBUG
    Serial.println("RC on_right");
#endif
        }
    }else  if(customKey=='9' ){
        if( padstate==0){ //
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(0,"on_back");
//          poststr(0,"on_back");
           mystat[0][0]=2;
#ifdef DEBUG
    Serial.println("RC on_back");
#endif
       }
    }
  }else{
      if( padstate==1){
          padstate=0;
          digitalWrite(ledpin[0][0], LOW);  // Turn the LED off by making the voltage HIGH
      }
  }
#endif  // RC

#ifdef KEYPAD
char customKey;
  customKey = customKeypad.getKey();
//    Serial.println(customKey);
  if (customKey != NO_KEY){
#ifdef DEBUG1
    Serial.println("KEYPAD get customKey");
#endif
    if(customKey=='0' ){
        if( padstate==0){
            padstate=1;
            if(mystat[0][0]==0){
                digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
                mqttsend(1,"on");
                poststr(1,"on");
                mystat[0][1]=1;
#ifdef DEBUG
                Serial.println("press 0, 0 on");
#endif
            }else{
                digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
                mqttsend(1,"off");
                poststr(1,"off");
                mystat[0][1]=0;
#ifdef DEBUG
                Serial.println("press 0, 0 off");
#endif
            }
        }
    }else  if(customKey=='1' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(2,"on");
            poststr(2,"on");
            mystat[0][2]=1;
#ifdef DEBUG
            Serial.println("press 1, 2 on");
#endif
        }
    }else  if(customKey=='2' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(3,"on");
            poststr(3,"on");
            mystat[0][3]=1;
#ifdef DEBUG
            Serial.println("press 2, 3 on");
#endif
        }
    }else  if(customKey=='3' ){
        if( padstate==0){
          padstate=1;
          digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
          mqttsend(4,"on");
          poststr(4,"on");
          mystat[0][4]=1;
#ifdef DEBUG
          Serial.println("press 3, 4 on");
#endif
        }
    }else  if(customKey=='4' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(1,"off");
            poststr(1,"off");
            mystat[0][1]=0;
#ifdef DEBUG
            Serial.println("press 4, 1 off");
#endif
        }
    }else  if(customKey=='5' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(2,"off");
            poststr(2,"off");
            mystat[0][2]=0;
#ifdef DEBUG
            Serial.println("press 5, 2 off");
#endif
        }
    }else  if(customKey=='6' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(3,"off");
            poststr(3,"off");
            mystat[0][3]=0;
#ifdef DEBUG
            Serial.println("press 6, 2 off");
#endif
        }
    }else  if(customKey=='7' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(4,"off");
            poststr(4,"off");
            mystat[0][4]=0;
#ifdef DEBUG
            Serial.println("press 7, 4 off");
#endif
        }
    }else      if(customKey=='8' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(1,"on");
            poststr(1,"on");
            mystat[0][1]=1;
#ifdef DEBUG
            Serial.println("press 8, 1 on");
#endif
        }
    }else  if(customKey=='9' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(0,"on_left");
/**********
            mqttsend(1,"on");
            poststr(1,"on");
            mystat[0][1]=1;
#ifdef DEBUG
            Serial.println("press 9, 1 on");
#endif
/********************/
        }
    }else  if(customKey=='A' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(0,"on_for");
/**********
            mqttsend(2,"on");
            poststr(2,"on");
            mystat[0][2]=1;
#ifdef DEBUG
            Serial.println("press A, 2 on");
#endif
/*****************/
        }
    }else  if(customKey=='B' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(0,"on_right");
/**********
            mqttsend(3,"on");
            poststr(3,"on");
            mystat[0][3]=1;
#ifdef DEBUG
            Serial.println("press B, 3 on");
#endif
/*******************/
        }
    }else  if(customKey=='C' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(1,"off");
            poststr(1,"off");
            mystat[0][1]=0;
#ifdef DEBUG
            Serial.println("press C, 1 off");
#endif
        }
    }else  if(customKey=='D' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(1,"off");
            poststr(1,"off");
            mystat[0][1]=0;
#ifdef DEBUG
            Serial.println("press D, 1 off");
#endif
        }
    }else  if(customKey=='E' ){
        if( padstate==0){
            padstate=1;
            mqttsend(0,"on_back");
/**********
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(2,"off");
            poststr(2,"off");
            mystat[0][2]=0;
#ifdef DEBUG
            Serial.println("press E, 2 off");
#endif
/****************/
        }
    }else  if(customKey=='F' ){
        if( padstate==0){
            padstate=1;
            digitalWrite(ledpin[0][0], LOW);   // Turn the LED on (Note that LOW is the voltage level
            mqttsend(0,"off");
/**********
            mqttsend(3,"off");
            poststr(3,"off");
            mystat[0][3]=0;
#ifdef DEBUG
            Serial.println("press F, 3 off");
#endif
/*******************/
        }
    }
  }
//  }else{
if(customKeypad.getState()==RELEASED){
   if( padstate==1){
          padstate=0;
          digitalWrite(ledpin[0][0], LOW);  // Turn the LED on by making the voltage LOW
#ifdef DEBUG
          Serial.print(customKey,HEX);
          Serial.print(padstate,HEX);
          Serial.println("key release!");
#endif
      }
  }
#endif  //KEYPAD
}
